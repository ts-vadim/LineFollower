/*
 * This file is a part of Dragster car set library.
 *
 * Declares the Dragster class used to perform basic interactions
 * with the robot (https://amperka.ru/product/dragster)
 *
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Harry Morgan <morgan@amperka.ru>
 * Refactored by: Yury Botov (by@amperka.com)
 * License: GPLv3, all text here must be included in any redistribution.
 */

#ifndef __DRAGSTER_H__
#define __DRAGSTER_H__

#include <Arduino.h>

/*
 * This file is a part of Dragster car set library.
 *
 * Defines: simple PID-regulator for Dragster 
 * � Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 * Refactor by: Ts. Vadim
 */

#ifndef __PID_DRAGSTER_H__
#define __PID_DRAGSTER_H__

class PID {

public:
    PID(double proporcional, double integral, double differencial)
    {
        _kp = proporcional;
        _ki = integral;
        _kd = differencial * 10;
        _previouse = 0.0;
        _accumulated = 0.0;
        _limitMin = -1.1;
        _limitMax = 1.1;
    }

    void setTunings(double proporcional, double integral, double differencial)
    {
        _kp = proporcional;
        _ki = integral;
        _kd = differencial;
    }

    void setOutputLimits(double min, double max)
    {
        _limitMin = min;
        _limitMax = max;
    }

    double compute(double deviation)
    {
        double p = _kp * deviation; // proporcional reaction
        double i = _ki * _accumulated; // one-step integral reaction
        double d = _kd * (deviation - _previouse); // one-step differencial reaction
        _previouse = deviation;
        _accumulated = (7 * _accumulated + deviation) / 8; // integration
        return -clamp(p + i + d, _limitMin, _limitMax); // reregulation supression
    }

private:
    double clamp(double source, double min, double max)
    {
        return (source < min) ? min : ((source > max) ? max : source);
    }

    double _kp; // Proportional parameter
    double _ki; // Integral parameter
    double _kd; // Differencial parameter

    double _previouse; // previouse step deviation value
    double _accumulated; // accumulated deviation

    double* _output;

    double _limitMin, _limitMax; // clamp limits
};

#endif //__PID_DRAGSTER_H__


/*
 * This file is a part of Octoliner library.
 *
 * Product page: https://amperka.ru/product/zelo-folow-line-sensor
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Vasily Basalaev <vasily@amperka.ru>
 * Refactored by: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 */

/*
 * This file is a part of Octoliner library.
 *
 * Product page: https://amperka.ru/product/zelo-folow-line-sensor
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Vasily Basalaev <vasily@amperka.ru>
 * Refactored by: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 */

#include <Arduino.h>
#include <Wire.h>

/*
 * This file is a part of Octoliner library.
 *
 * Product page: https://amperka.ru/product/zelo-folow-line-sensor
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Vasily Basalaev <vasily@amperka.ru>
 * Refactored by: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 */

#ifndef __I2CIOCOMMANDS_H__
#define __I2CIOCOMMANDS_H__

enum IOcommand {
    // Basic functions
    UID = 0x00
    /*
      * command     (0x00)
      * argument    no
      * answer      u32
      
      Return 32 bit unic id stm32f030f4p6 (UID)
      (temperature and analog reference calibration values)
      */

    ,
    RESET_SLAVE
    /*
      * command     (0x01)
      * argument    no
      * answer      no
      
      Reset chip 
      */

    ,
    CHANGE_I2C_ADDR
    /*
      * command     (0x02)
      * argument    u8
      * answer      no

      Set new I2C address on chip. Restart I2C peripheral with new slave address.
      After power off or reset, device will start with old I2C address
      */

    ,
    SAVE_I2C_ADDR
    /*
      * command     (0x03)
      * argument    no
      * answer      no

      Save current I2C address on flash, if it was changed by 
      CHANGE_I2C_ADDR, or CHANGE_I2C_ADDR_IF_UID_OK command
      After power off or reset, device will start with new I2C address
      */

    ,
    PORT_MODE_INPUT
    /*
      * command     (0x04)
      * argument    u16
      * answer      no

      Set input mode on virtual port 0 pins. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be set on input mode
      */

    ,
    PORT_MODE_PULLUP
    /*
      * command     (0x05)
      * argument    u16
      * answer      no

      Set input pullup mode on virtual port 0 pins. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be set on input pullup mode
      */

    ,
    PORT_MODE_PULLDOWN
    /*
      * command     (0x06)
      * argument    u16
      * answer      no

      Set input pulldown mode on virtual port 0 pins. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be set on input pulldown mode
      */

    ,
    PORT_MODE_OUTPUT
    /*
      * command     (0x07)
      * argument    u16
      * answer      no

      Set output mode on virtual port 0 pins. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be set on output mode with low value
      */

    ,
    DIGITAL_READ
    /*
      * command     (0x08)
      * argument    no
      * answer      u16

      Return digital value of virtual port 0. Answer 
      0b0000000000000101 means virtual pins 0 and 2 is high, and all other pins is low.
      Not change pin mode
      */

    ,
    DIGITAL_WRITE_HIGH
    /*
      * command     (0x09)
      * argument    u16
      * answer      no

      Set high digital value of virtual port 0 with change pin mode to output. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be output with high value.
      All other pins value is not change.
      Change pin mode to output
      */

    ,
    DIGITAL_WRITE_LOW
    /*
      * command     (0x0A)
      * argument    u16
      * answer      no

      Set low digital value of virtual port 0 with change pin mode to output. If argument is 
      0b0000000000000101, virtual pins 0 and 2 will be output with low value.
      All other pins value is not change.
      Change pin mode to output
      */

    ,
    ANALOG_WRITE
    /*
      * command     (0x0B)
      * arguments   u8    - pin
                    u16   - value
      * answer      no

      Writes an analog value (PWM wave) to a pin.
      The pin will generate a steady square wave of the specified duty cycle
      Default frequency of the PWM signal 1 kHz
      Change pin mode to output
      */

    ,
    ANALOG_READ // Считать значениие с АЦП
    /*
      * command     (0x0C)
      * arguments   u8    - pin
      * answer      u16

      Return analog values of pin (TODO - adc max value). ADC conversion is never stop,
      so value can be readed immediately
      Not change pin mode
      */

    ,
    PWM_FREQ
    /*
      * command     (0x0D)
      * arguments   u16   - value
      * answer      no

      Set the PWM frequency on all pins at the same time. The PWM filling factor does not change.
      */

    ,
    ADC_SPEED
    /*
      * command     (0x0E)
      * arguments   u8   - value in range 0..7
      * answer      no

      Set ADC conversion speed. Value must be in range 0..7.
      Default value - 6 (TODO - fix it. Need to filtering off and set 7 as default)
    
      0: Sampling time 1.5 ADC clock cycle
      1: Sampling time 7.5 ADC clock cycles
      2: Sampling time 13.5 ADC clock cycles
      3: Sampling time 28.5 ADC clock cycles
      4: Sampling time 41.5 ADC clock cycles
      5: Sampling time 55.5 ADC clock cycles
      6: Sampling time 71.5 ADC clock cycles
      7: Sampling time 239.5 ADC clock cycles
      */

    ,
    MASTER_READED_UID
    /*
      * command     (0x0F)
      * arguments   u32   - UID
      * answer      no

      When many I2Cadio devices have the same I2C address, I2C master can read UID of devices
      with this address (UID command). Only one device can send correct UID 
      (smallest UID. See I2C arbitration). To set new addres on that device, I2C master must
      send readed UID to I2C slaves with command MASTER_READED_UID. If UID is belongs to slave,
      that slave device can change i2c address with the command CHANGE_I2C_ADDR_IF_UID_OK
      */

    ,
    CHANGE_I2C_ADDR_IF_UID_OK
    /*
      * command     (0x10)
      * arguments   u8   - new I2C address
      * answer      no

      Set new I2C address on slave device, if slave recieve his UID on MASTER_READED_UID command
      */

    ,
    SAY_SLOT
    /*
      * command     (0x11)
      * arguments   no
      * answer      u32   - "slot"

      Command to identify of I2Cadio device on I2C address. If slave answer is "slot", then we can addressing it
      with UID (see MASTER_READED_UID)
      */

    // 0x20 - Advanced ADC functions
    ,
    ADC_LOWPASS_FILTER_ON = 0x20 // command
    /*
      * command     (0x20)
      * arguments   no
      * answer      no
      
      turning on ADC low pass filter. Default state
      */

    ,
    ADC_LOWPASS_FILTER_OFF // command
    /*
      * command     (0x21)
      * arguments   no
      * answer      no
      
      turning of ADC low pass filter.
      */

    ,
    ADC_AS_DIGITAL_PORT_SET_TRESHOLD
    /*
      * command     (0x22)
      * arguments   u16   - treshold
      * answer      no
      
      Set treshold for ADC_AS_DIGITAL_PORT_READ
      */

    ,
    ADC_AS_DIGITAL_PORT_READ
    /*
      * command     (0x23)
      * arguments   no
      * answer      u16
      
      Return digital value of virtual port 0 from pins analog value. Answer 
      0b0000000000000101 means analog value on virtual pins 0 and 2 is equal or larger than treshold
      Not change pin mode
      */

    ,
    ENCODER_SET_PINS = 0x30
    /*
      * command     (0x30)
      * arguments   u8 - encoder nummber, u8 - encoder A<<4|B pin number
      * answer      
      
      Add encoder on A and B pins, packed on u8.
      4 encoders max
      */

    ,
    ENCODER_GET_DIFF_VALUE
    /*
      * command     (0x31)
      * arguments   u8 - encoder number
      * answer      int8_t - diff value
      
      Return difference steps after last encoder read.
      4 encoders max
      */

    // TODO: section
    //    ,
    // 0x40 -Advanced PWM functions
    ,
    PWM_ANALOG_WRITE_U8 = 0x40 // 1b in
    // 0x60 -Advanced Digital functions
    // 0x80 -Software interfaces

    // ... 8 groups, 32 commands each

    // etc - start at 0xE0
    ,
    ETC_VERSION = 0xE0 // command, 4b answer
    ,
    ETC_ACT_LED_ENABLE // command
    ,
    ETC_ACT_LED_DISABLE // command
    ,
    ETC_ACT_LED_BLINK_WITH_COUNTER // 1b in
    ,
    ETC_NUM_DIGITAL_PINS,
    ETC_NUM_ANALOG_INPUTS
};
// section :TODO

#endif // __I2CIOCOMMANDS_H__


#ifndef __GPIOEXPANDER_H__
#define __GPIOEXPANDER_H__

#ifndef INPUT_PULLDOWN
#define INPUT_PULLDOWN 0x3
#endif

#ifndef DEFAULT_GPIOEXP_ADDR
#define DEFAULT_GPIOEXP_ADDR 42
#endif

#ifndef I2CIO_PIN_COUNT
#define I2CIO_PIN_COUNT 10
#endif

// we need to say something to identity... Let's say "slot"
#define IS_HE_SAY_SLOT (uint32_t)(((uint32_t)'s' << 24) | ((uint32_t)'l' << 16) | ((uint32_t)'o' << 8) | ((uint32_t)'t'))

class GpioExpander {
public:
    GpioExpander(uint8_t i2cAddress = DEFAULT_GPIOEXP_ADDR);
    void begin(void);
    void begin(TwoWire* wire);
    void reset(void);
    void pinMode(uint8_t pin, uint8_t mode);
    void analogReadResolution(uint8_t res);
    void analogWriteResolution(uint8_t res);
    void digitalWrite(uint8_t pin, bool value);
    void analogWrite(uint8_t pin, uint16_t pulseWidth);
    int16_t digitalRead(uint8_t pin);
    int16_t analogRead(uint8_t pin);
    void changeAddr(uint8_t newAddr);
    void changeAddrWithUID(uint8_t newAddr);
    void saveAddr(void);
    void pinModePort(uint16_t value, uint8_t mode);
    void digitalWritePort(uint16_t value);
    int16_t digitalReadPort(void);
    void pwmFreq(uint16_t freq);
    uint32_t getUID(void);
    void adcSpeed(uint8_t speed);
    void adcFilter(bool enable);
    void setEncoderPins(uint8_t encoder, uint8_t pinA, uint8_t pinB);
    int8_t readEncoderDiff(uint8_t encoder);

private:
    TwoWire* _wire;
    uint8_t _i2cAddress;
    uint8_t _analogWriteResolution = 8;
    uint8_t _analogReadResolution = 10;
    void writeCmdPin(IOcommand command, uint8_t pin, bool sendStop = true);
    void writeCmdPin16Val(IOcommand command, uint8_t pin, uint16_t value, bool sendStop = true);
    void writeCmd16BitData(IOcommand command, uint16_t data);
    void writeCmd8BitData(IOcommand command, uint8_t data);
    void writeCmd(IOcommand command, bool sendStop = true);
    int8_t readInt8Bit(void);
    int16_t read16Bit(void); // Name change to readInt16Bit?
    uint32_t read32Bit(void);
    uint16_t mapResolution(uint16_t value, uint8_t from, uint8_t to);
};


/*
 * This file is a part of Octoliner library.
 *
 * Product page: https://amperka.ru/product/zelo-folow-line-sensor
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Vasily Basalaev <vasily@amperka.ru>
 * Refactored by: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 */



GpioExpander::GpioExpander(uint8_t i2cAddress) {
    _i2cAddress = i2cAddress;
}

void GpioExpander::begin(void) {
    begin(&Wire);
}

void GpioExpander::begin(TwoWire* wire) {
    _wire = wire;
}

void GpioExpander::reset(void) {
    writeCmd(RESET_SLAVE);
}

void GpioExpander::pinMode(uint8_t pin, uint8_t mode) {
    pinModePort(1 << pin, mode);
}

void GpioExpander::digitalWrite(uint8_t pin, bool value) {
    uint16_t sendData = 1 << pin;
    if (value) {
        writeCmd16BitData(DIGITAL_WRITE_HIGH, sendData);
    } else {
        writeCmd16BitData(DIGITAL_WRITE_LOW, sendData);
    }
}

uint16_t GpioExpander::mapResolution(uint16_t value, uint8_t from, uint8_t to) {
    if (from == to)
        return value;
    if (from > to)
        return value >> (from - to);
    else
        return value << (to - from);
}

void GpioExpander::analogWriteResolution(uint8_t res) {
    _analogWriteResolution = res;
}

void GpioExpander::analogReadResolution(uint8_t res) {
    _analogReadResolution = res;
}

void GpioExpander::analogWrite(uint8_t pin, uint16_t pulseWidth) {
    uint16_t val = mapResolution(pulseWidth, _analogWriteResolution, 16);
    writeCmdPin16Val(ANALOG_WRITE, pin, val, true);
}

int16_t GpioExpander::digitalRead(uint8_t pin) {
    int16_t portValue = digitalReadPort();
    if (portValue >= 0)
        return (portValue & (1 << pin) ? 1 : 0);
    else
        return 0;
}

int16_t GpioExpander::analogRead(uint8_t pin) {
    writeCmdPin(ANALOG_READ, pin, true);
    int16_t result = read16Bit();
    if (result >= 0) {
        result = (int16_t)mapResolution((uint16_t)result, 12, _analogReadResolution);
    }
    return result;
}

void GpioExpander::changeAddr(uint8_t newAddr) {
    writeCmd8BitData(CHANGE_I2C_ADDR, newAddr);
    _i2cAddress = newAddr;
}

void GpioExpander::changeAddrWithUID(uint8_t newAddr) {
    uint32_t uid = getUID();

    delay(1);
    // address set on class instantiation
    _wire->beginTransmission(_i2cAddress);

    _wire->write((uint8_t)MASTER_READED_UID);
    // upper byte of data/setting to be sent to device
    _wire->write((uid >> 24) & 0xff);
    // third byte of data/setting to be sent to device
    _wire->write((uid >> 16) & 0xff);
    // second byte of data/setting to be sent to device
    _wire->write((uid >> 8) & 0xff);
    // lower byte of data/setting to be sent to device
    _wire->write(uid & 0xff);
    _wire->endTransmission();

    delay(1);

    writeCmd8BitData(CHANGE_I2C_ADDR_IF_UID_OK, newAddr);
    _i2cAddress = newAddr;

    delay(1);
}

void GpioExpander::saveAddr() {
    writeCmd(SAVE_I2C_ADDR);
}

void GpioExpander::pinModePort(uint16_t value, uint8_t mode) {
    switch (mode) {
    case INPUT:
        writeCmd16BitData(PORT_MODE_INPUT, value);
        break;
    case OUTPUT:
        writeCmd16BitData(PORT_MODE_OUTPUT, value);
        break;
    case INPUT_PULLUP:
        writeCmd16BitData(PORT_MODE_PULLUP, value);
        break;
    case INPUT_PULLDOWN:
        writeCmd16BitData(PORT_MODE_PULLDOWN, value);
        break;
    default:
        break;
    }
}

void GpioExpander::digitalWritePort(uint16_t value) {
    writeCmd16BitData(DIGITAL_WRITE_HIGH, value);
    writeCmd16BitData(DIGITAL_WRITE_LOW, ~value);
}

int16_t GpioExpander::digitalReadPort() {
    // check. Need it? maybe true?
    writeCmd(DIGITAL_READ, false);
    return read16Bit();
}

void GpioExpander::pwmFreq(uint16_t freq) {
    writeCmd16BitData(PWM_FREQ, freq);
}

uint32_t GpioExpander::getUID() {
    writeCmd(UID);
    return read32Bit();
}

void GpioExpander::adcSpeed(uint8_t speed) {
    // speed must be < 8. Smaller is faster, but dirty
    writeCmd8BitData(ADC_SPEED, speed & 0x07);
}

void GpioExpander::adcFilter(bool enable) {
    IOcommand command = enable ? ADC_LOWPASS_FILTER_ON : ADC_LOWPASS_FILTER_OFF;
    writeCmd(command);
}

void GpioExpander::setEncoderPins(uint8_t encoder, uint8_t pinA, uint8_t pinB) {
    uint8_t pins = (pinA << 4) | (pinB & 0x0f);
    uint16_t payload = ((uint16_t)encoder << 8) | pins;
    writeCmd16BitData(ENCODER_SET_PINS, payload);
}

int8_t GpioExpander::readEncoderDiff(uint8_t encoder) {
    writeCmdPin(ENCODER_GET_DIFF_VALUE, encoder, true);
    return readInt8Bit();
}

void GpioExpander::writeCmdPin(IOcommand command, uint8_t pin, bool sendStop) {
    _wire->beginTransmission(_i2cAddress);
    _wire->write((uint8_t)command);
    _wire->write(pin);
    _wire->endTransmission(sendStop);
}

void GpioExpander::writeCmdPin16Val(IOcommand command, uint8_t pin, uint16_t value, bool sendStop) {
    _wire->beginTransmission(_i2cAddress);
    _wire->write((uint8_t)command);
    _wire->write(pin);
    // upper byte of data/setting to be sent to device
    _wire->write((value >> 8) & 0xff);
    // lower byte of data/setting to be sent to device
    _wire->write(value & 0xff);
    _wire->endTransmission(sendStop);
}

void GpioExpander::writeCmd16BitData(IOcommand command, uint16_t data) {
    // address set on class instantiation
    _wire->beginTransmission(_i2cAddress);
    _wire->write((uint8_t)command);
    // upper byte of data/setting to be sent to device
    _wire->write((data >> 8) & 0xff);
    // lower byte of data/setting to be sent to device
    _wire->write(data & 0xff);
    _wire->endTransmission();
}

void GpioExpander::writeCmd8BitData(IOcommand command, uint8_t data) {
    // address set on class instantiation
    _wire->beginTransmission(_i2cAddress);
    _wire->write((uint8_t)command);
    // data/setting to be sent to device
    _wire->write(data);
    _wire->endTransmission();
}

void GpioExpander::writeCmd(IOcommand command, bool sendStop) {
    _wire->beginTransmission(_i2cAddress);
    _wire->write((uint8_t)command);
    _wire->endTransmission(sendStop);
}

int8_t GpioExpander::readInt8Bit() {
    const uint8_t byteCount = 1;
    _wire->requestFrom(_i2cAddress, byteCount);
    if (_wire->available() != byteCount)
        return -1;
    else
        return (int8_t)_wire->read();
}

int16_t GpioExpander::read16Bit() {
    int16_t result = -1;
    const uint8_t byteCount = 2;
    _wire->requestFrom(_i2cAddress, byteCount);
    if (_wire->available() != byteCount)
        return result;
    result = _wire->read();
    result = (result << 8) | _wire->read();
    return result;
}

uint32_t GpioExpander::read32Bit() {
    // https://www.youtube.com/watch?v=171skzi5BKc
    uint32_t result = 0;
    const uint8_t byteCount = 4;
    _wire->requestFrom(_i2cAddress, byteCount);
    if (_wire->available() != byteCount)
        return 0xffffffff;
    for (uint8_t i = 0; i < byteCount; i++) {
        result = (result << 8) | _wire->read();
    }
    return result;
}



#endif //__GPIOEXPANDER_H__

#include <Arduino.h>
#include <Wire.h>

#ifndef __OCTOLINER_H__
#define __OCTOLINER_H__

// Minimum adequate sensitivity. For all values below this, channels always
// see black even on mirror/white surfaces
constexpr uint8_t MIN_SENSITIVITY = 120;
// All analog values above this are considered black
constexpr int16_t BLACK_THRESHOLD = 100;

class Octoliner : private GpioExpander {
public:
    Octoliner(uint8_t i2cAddress = 42);
    void begin();
    void begin(TwoWire* wire);
    int16_t analogRead(uint8_t sensor);
    void analogReadAll(int16_t* analogValues);
    uint8_t digitalReadAll();

    float trackLine();
    float trackLine(uint8_t pattern);
    float trackLine(int16_t* analogValues);

    virtual uint8_t mapAnalogToPattern(int16_t* analogValues) const;
    virtual float mapPatternToLine(uint8_t pattern) const;

    bool optimizeSensitivityOnBlack();
    void setSensitivity(uint8_t sense);
    uint8_t getSensitivity() const;

    void changeAddr(uint8_t newAddr);
    void saveAddr();

    // Deprecated mapLine
    float mapLine(int* analogValues);

private:
    uint8_t countOfBlack();
    static constexpr uint8_t _IRLedsPin = 9;
    static constexpr uint8_t _sensePin = 0;
    static const uint8_t _sensorPinMap[8];
    uint8_t _sensitivity;
    float _previousValue;
};


/*
 * This file is a part of Octoliner library.
 *
 * Product page: https://amperka.ru/product/zelo-folow-line-sensor
 * © Amperka LLC (https://amperka.com, dev@amperka.com)
 * 
 * Author: Vasily Basalaev <vasily@amperka.ru>
 * Refactored by: Yury Botov <by@amperka.com>
 * License: GPLv3, all text here must be included in any redistribution.
 */


const uint8_t Octoliner::_sensorPinMap[] = {
    4, 5, 6, 8, 7, 3, 2, 1
};

Octoliner::Octoliner(uint8_t i2cAddress)
    : GpioExpander(i2cAddress) {
    _previousValue = 0.;
    _sensitivity = 208;
}

void Octoliner::begin() {
    Octoliner::begin(&Wire);
}

void Octoliner::begin(TwoWire* wire) {
    wire->begin();
    GpioExpander::begin(wire);
    GpioExpander::pwmFreq(8000); // ~ 250 pwm levels
    GpioExpander::pinMode(_IRLedsPin, OUTPUT);
    GpioExpander::digitalWrite(_IRLedsPin, HIGH);
}

void Octoliner::setSensitivity(uint8_t sense) {
    _sensitivity = sense;
    analogWrite(_sensePin, _sensitivity);
}

int16_t Octoliner::analogRead(uint8_t sensor) {
    return (int16_t)GpioExpander::analogRead(_sensorPinMap[sensor & 0x07]);
}

void Octoliner::analogReadAll(int16_t* analogValues) {
    for (uint8_t i = 0; i < 8; i++) {
        analogValues[i] = Octoliner::analogRead(i);
    }
}

uint8_t Octoliner::mapAnalogToPattern(int16_t* analogValues) const {
    uint8_t pattern = 0;

    // search min and max values
    int16_t min = 32767;
    int16_t max = 0;
    for (uint8_t i = 0; i < 8; i++) {
        if (analogValues[i] < min)
            min = analogValues[i];
        if (analogValues[i] > max)
            max = analogValues[i];
    }
    // calculate threshold level
    int16_t threshold = min + (max - min) / 2;
    // create bit pattern
    for (uint8_t i = 0; i < 8; i++) {
        pattern = (pattern << 1) + ((analogValues[i] < threshold) ? 0 : 1);
    }
    return pattern;
}

float Octoliner::mapPatternToLine(uint8_t binaryLine) const {
    switch (binaryLine) {
    case 0b00011000: return 0;
    case 0b00010000: return 0.25;
    case 0b00111000: return 0.25;
    case 0b00001000: return -0.25;
    case 0b00011100: return -0.25;
    case 0b00110000: return 0.375;
    case 0b00001100: return -0.375;
    case 0b00100000: return 0.5;
    case 0b01110000: return 0.5;
    case 0b00000100: return -0.5;
    case 0b00001110: return -0.5;
    case 0b01100000: return 0.625;
    case 0b11100000: return 0.625;
    case 0b00000110: return -0.625;
    case 0b00000111: return -0.625;
    case 0b01000000: return 0.75;
    case 0b11110000: return 0.75;
    case 0b00000010: return -0.75;
    case 0b00001111: return -0.75;
    case 0b11000000: return 0.875;
    case 0b00000011: return -0.875;
    case 0b10000000: return 1.0;
    case 0b00000001: return -1.0;
    default: return NAN;
    }
    return NAN;
}

float Octoliner::trackLine() {
    int16_t analogValues[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    analogReadAll(analogValues);
    return trackLine(analogValues);
}

float Octoliner::trackLine(uint8_t pattern) {
    float result = mapPatternToLine(pattern);
    result = isnan(result) ? _previousValue : result;
    _previousValue = result;
    return result;
}

float Octoliner::trackLine(int16_t* analogValues) {
    return trackLine(mapAnalogToPattern(analogValues));
}

uint8_t Octoliner::digitalReadAll() {
    int16_t analogValues[8] = { 0, 0, 0, 0, 0, 0, 0, 0 };
    analogReadAll(analogValues);
    return mapAnalogToPattern(analogValues);
}

uint8_t Octoliner::countOfBlack() {
    uint8_t count = 0;
    for (uint8_t i = 0; i < 8; i++) {
        if (analogRead(i) > BLACK_THRESHOLD)
            count++;
    }
    return count;
}

bool Octoliner::optimizeSensitivityOnBlack() {
    uint8_t sens;
    uint8_t sensitivityBackup = getSensitivity();
    // Give more time to settle RCL circuit at first time
    setSensitivity(255);
    delay(200);
    // Starting at the highest possible sensitivity read all channels at each iteration
    // to find the level when all the channels become black
    for (sens = 255; sens > MIN_SENSITIVITY; sens -= 5) {
        setSensitivity(sens);
        // Give some time to settle RCL circuit
        delay(100);
        if (countOfBlack() == 8)
            break;
    }
    if (sens <= MIN_SENSITIVITY) { // Somthing is broken
        setSensitivity(sensitivityBackup);
        return false;
    }

    // Forward fine search to find the level when at least one sensor value will
    // become back white
    for (/*sens = sens*/; sens < 255; sens++) {
        setSensitivity(sens);
        delay(50);
        if (countOfBlack() != 8)
            break;
    }
    if (sens == 255) {
        // Environment has changed since the start of the process
        setSensitivity(sensitivityBackup);
        return false;
    }
    // Magic 5 step back to fall back to all-eight-black
    sens -= 5;
    setSensitivity(sens);
    return true;
}

uint8_t Octoliner::getSensitivity() const {
    return _sensitivity;
}

void Octoliner::changeAddr(uint8_t newAddr) {
    GpioExpander::changeAddr(newAddr);
}

void Octoliner::saveAddr(void) {
    GpioExpander::saveAddr();
}

/*---------  Deprecated ----------*/

float Octoliner::mapLine(int* analogValues) {
    return trackLine((int16_t*)analogValues);
}










#endif // __OCTOLINER_H__


#ifndef TROYKA_LED_MATRIX_H
#define TROYKA_LED_MATRIX_H

#include <Wire.h>
#include <avr/pgmspace.h>

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/
/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_basic
// Contains an 8x8 font map for unicode points U+0000 - U+007F (basic latin)
const uint8_t font8x8_basic[128][8] PROGMEM = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0000 (nul)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0001
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0002
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0003
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0004
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0005
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0006
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0007
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0008
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0009
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+000F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0010
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0011
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0012
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0013
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0014
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0015
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0016
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0017
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0018
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0019
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+001F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
    { 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
    { 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
    { 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
    { 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
    { 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
    { 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
    { 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
    { 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
    { 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
    { 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
    { 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
    { 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
    { 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
    { 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
    { 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
    { 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
    { 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
    { 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
    { 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
    { 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
    { 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
    { 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
    { 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
    { 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (//)
    { 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
    { 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
    { 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
    { 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
    { 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
    { 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
    { 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
    { 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
    { 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
    { 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
    { 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
    { 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
    { 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
    { 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
    { 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
    { 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
    { 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
    { 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
    { 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
    { 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
    { 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
    { 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
    { 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
    { 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
    { 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
    { 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
    { 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
    { 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
    { 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
    { 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
    { 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
    { 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
    { 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
    { 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
    { 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
    { 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
    { 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
    { 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
    { 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
    { 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
    { 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
    { 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
    { 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
    { 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+007F
};


/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_0080
// Contains an 8x8 font map for unicode points U+0080 - U+009F (C1/C2 control)
const uint8_t font8x8_control[32][8] PROGMEM = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0080
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0081
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0082
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0083
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0084
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0085
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0086
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0087
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0088
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0089
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+008F
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0090
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0091
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0092
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0093
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0094
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0095
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0096
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0097
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0098
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0099
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+009A
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+009B
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+009C
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+009D
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+009E
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+009F
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_00A0
// Contains an 8x8 font map for unicode points U+00A0 - U+00FF (extended latin)
const uint8_t font8x8_ext_latin[96][8] PROGMEM = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+00A0 (no break space)
    { 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x18, 0x00},   // U+00A1 (inverted !)
    { 0x18, 0x18, 0x7E, 0x03, 0x03, 0x7E, 0x18, 0x18},   // U+00A2 (dollarcents)
    { 0x1C, 0x36, 0x26, 0x0F, 0x06, 0x67, 0x3F, 0x00},   // U+00A3 (pound sterling)
    { 0x00, 0x00, 0x63, 0x3E, 0x36, 0x3E, 0x63, 0x00},   // U+00A4 (currency mark)
    { 0x33, 0x33, 0x1E, 0x3F, 0x0C, 0x3F, 0x0C, 0x0C},   // U+00A5 (yen)
    { 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+00A6 (broken pipe)
    { 0x7C, 0xC6, 0x1C, 0x36, 0x36, 0x1C, 0x33, 0x1E},   // U+00A7 (paragraph)
    { 0x33, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+00A8 (diaeresis)
    { 0x3C, 0x42, 0x99, 0x85, 0x85, 0x99, 0x42, 0x3C},   // U+00A9 (copyright symbol)
    { 0x3C, 0x36, 0x36, 0x7C, 0x00, 0x00, 0x00, 0x00},   // U+00AA (superscript a)
    { 0x00, 0xCC, 0x66, 0x33, 0x66, 0xCC, 0x00, 0x00},   // U+00AB (<<)
    { 0x00, 0x00, 0x00, 0x3F, 0x30, 0x30, 0x00, 0x00},   // U+00AC (gun pointing left)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+00AD (soft hyphen)
    { 0x3C, 0x42, 0x9D, 0xA5, 0x9D, 0xA5, 0x42, 0x3C},   // U+00AE (registered symbol)
    { 0x7E, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+00AF (macron)
    { 0x1C, 0x36, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00},   // U+00B0 (degree)
    { 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x7E, 0x00},   // U+00B1 (plusminus)
    { 0x1C, 0x30, 0x18, 0x0C, 0x3C, 0x00, 0x00, 0x00},   // U+00B2 (superscript 2)
    { 0x1C, 0x30, 0x18, 0x30, 0x1C, 0x00, 0x00, 0x00},   // U+00B2 (superscript 3)
    { 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+00B2 (aigu)
    { 0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x03},   // U+00B5 (mu)
    { 0xFE, 0xDB, 0xDB, 0xDE, 0xD8, 0xD8, 0xD8, 0x00},   // U+00B6 (pilcrow)
    { 0x00, 0x00, 0x00, 0x18, 0x18, 0x00, 0x00, 0x00},   // U+00B7 (central dot)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x30, 0x1E},   // U+00B8 (cedille)
    { 0x08, 0x0C, 0x08, 0x1C, 0x00, 0x00, 0x00, 0x00},   // U+00B9 (superscript 1)
    { 0x1C, 0x36, 0x36, 0x1C, 0x00, 0x00, 0x00, 0x00},   // U+00BA (superscript 0)
    { 0x00, 0x33, 0x66, 0xCC, 0x66, 0x33, 0x00, 0x00},   // U+00BB (>>)
    { 0xC3, 0x63, 0x33, 0xBD, 0xEC, 0xF6, 0xF3, 0x03},   // U+00BC (1/4)
    { 0xC3, 0x63, 0x33, 0x7B, 0xCC, 0x66, 0x33, 0xF0},   // U+00BD (1/2)
    { 0x03, 0xC4, 0x63, 0xB4, 0xDB, 0xAC, 0xE6, 0x80},   // U+00BE (3/4)
    { 0x0C, 0x00, 0x0C, 0x06, 0x03, 0x33, 0x1E, 0x00},   // U+00BF (inverted ?)
    { 0x07, 0x00, 0x1C, 0x36, 0x63, 0x7F, 0x63, 0x00},   // U+00C0 (A grave)
    { 0x70, 0x00, 0x1C, 0x36, 0x63, 0x7F, 0x63, 0x00},   // U+00C1 (A aigu)
    { 0x1C, 0x36, 0x00, 0x3E, 0x63, 0x7F, 0x63, 0x00},   // U+00C2 (A circumflex)
    { 0x6E, 0x3B, 0x00, 0x3E, 0x63, 0x7F, 0x63, 0x00},   // U+00C3 (A ~)
    { 0x63, 0x1C, 0x36, 0x63, 0x7F, 0x63, 0x63, 0x00},   // U+00C4 (A umlaut)
    { 0x0C, 0x0C, 0x00, 0x1E, 0x33, 0x3F, 0x33, 0x00},   // U+00C5 (A ring)
    { 0x7C, 0x36, 0x33, 0x7F, 0x33, 0x33, 0x73, 0x00},   // U+00C6 (AE)
    { 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x18, 0x30, 0x1E},   // U+00C7 (C cedille)
    { 0x07, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00},   // U+00C8 (E grave)
    { 0x38, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00},   // U+00C9 (E aigu)
    { 0x0C, 0x12, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00},   // U+00CA (E circumflex)
    { 0x36, 0x00, 0x3F, 0x06, 0x1E, 0x06, 0x3F, 0x00},   // U+00CB (E umlaut)
    { 0x07, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00CC (I grave)
    { 0x38, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00CD (I aigu)
    { 0x0C, 0x12, 0x00, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+00CE (I circumflex)
    { 0x33, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00CF (I umlaut)
    { 0x3F, 0x66, 0x6F, 0x6F, 0x66, 0x66, 0x3F, 0x00},   // U+00D0 (Eth)
    { 0x3F, 0x00, 0x33, 0x37, 0x3F, 0x3B, 0x33, 0x00},   // U+00D1 (N ~)
    { 0x0E, 0x00, 0x18, 0x3C, 0x66, 0x3C, 0x18, 0x00},   // U+00D2 (O grave)
    { 0x70, 0x00, 0x18, 0x3C, 0x66, 0x3C, 0x18, 0x00},   // U+00D3 (O aigu)
    { 0x3C, 0x66, 0x18, 0x3C, 0x66, 0x3C, 0x18, 0x00},   // U+00D4 (O circumflex)
    { 0x6E, 0x3B, 0x00, 0x3E, 0x63, 0x63, 0x3E, 0x00},   // U+00D5 (O ~)
    { 0xC3, 0x18, 0x3C, 0x66, 0x66, 0x3C, 0x18, 0x00},   // U+00D6 (O umlaut)
    { 0x00, 0x36, 0x1C, 0x08, 0x1C, 0x36, 0x00, 0x00},   // U+00D7 (multiplicative x)
    { 0x5C, 0x36, 0x73, 0x7B, 0x6F, 0x36, 0x1D, 0x00},   // U+00D8 (O stroke)
    { 0x0E, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},   // U+00D9 (U grave)
    { 0x70, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00},   // U+00DA (U aigu)
    { 0x3C, 0x66, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x00},   // U+00DB (U circumflex)
    { 0x33, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+00DC (U umlaut)
    { 0x70, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x00},   // U+00DD (Y aigu)
    { 0x0F, 0x06, 0x3E, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+00DE (Thorn)
    { 0x00, 0x1E, 0x33, 0x1F, 0x33, 0x1F, 0x03, 0x03},   // U+00DF (beta)
    { 0x07, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x7E, 0x00},   // U+00E0 (a grave)
    { 0x38, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x7E, 0x00},   // U+00E1 (a aigu)
    { 0x7E, 0xC3, 0x3C, 0x60, 0x7C, 0x66, 0xFC, 0x00},   // U+00E2 (a circumflex)
    { 0x6E, 0x3B, 0x1E, 0x30, 0x3E, 0x33, 0x7E, 0x00},   // U+00E3 (a ~)
    { 0x33, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x7E, 0x00},   // U+00E4 (a umlaut)
    { 0x0C, 0x0C, 0x1E, 0x30, 0x3E, 0x33, 0x7E, 0x00},   // U+00E5 (a ring)
    { 0x00, 0x00, 0xFE, 0x30, 0xFE, 0x33, 0xFE, 0x00},   // U+00E6 (ae)
    { 0x00, 0x00, 0x1E, 0x03, 0x03, 0x1E, 0x30, 0x1C},   // U+00E7 (c cedille)
    { 0x07, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00},   // U+00E8 (e grave)
    { 0x38, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00},   // U+00E9 (e aigu)
    { 0x7E, 0xC3, 0x3C, 0x66, 0x7E, 0x06, 0x3C, 0x00},   // U+00EA (e circumflex)
    { 0x33, 0x00, 0x1E, 0x33, 0x3F, 0x03, 0x1E, 0x00},   // U+00EB (e umlaut)
    { 0x07, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00EC (i grave)
    { 0x1C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00ED (i augu)
    { 0x3E, 0x63, 0x1C, 0x18, 0x18, 0x18, 0x3C, 0x00},   // U+00EE (i circumflex)
    { 0x33, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+00EF (i umlaut)
    { 0x1B, 0x0E, 0x1B, 0x30, 0x3E, 0x33, 0x1E, 0x00},   // U+00F0 (eth)
    { 0x00, 0x1F, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x00},   // U+00F1 (n ~)
    { 0x00, 0x07, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+00F2 (o grave)
    { 0x00, 0x38, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+00F3 (o aigu)
    { 0x1E, 0x33, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+00F4 (o circumflex)
    { 0x6E, 0x3B, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+00F5 (o ~)
    { 0x00, 0x33, 0x00, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+00F6 (o umlaut)
    { 0x18, 0x18, 0x00, 0x7E, 0x00, 0x18, 0x18, 0x00},   // U+00F7 (division)
    { 0x00, 0x60, 0x3C, 0x76, 0x7E, 0x6E, 0x3C, 0x06},   // U+00F8 (o stroke)
    { 0x00, 0x07, 0x00, 0x33, 0x33, 0x33, 0x7E, 0x00},   // U+00F9 (u grave)
    { 0x00, 0x38, 0x00, 0x33, 0x33, 0x33, 0x7E, 0x00},   // U+00FA (u aigu)
    { 0x1E, 0x33, 0x00, 0x33, 0x33, 0x33, 0x7E, 0x00},   // U+00FB (u circumflex)
    { 0x00, 0x33, 0x00, 0x33, 0x33, 0x33, 0x7E, 0x00},   // U+00FC (u umlaut)
    { 0x00, 0x38, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+00FD (y aigu)
    { 0x00, 0x00, 0x06, 0x3E, 0x66, 0x3E, 0x06, 0x00},   // U+00FE (thorn)
    { 0x00, 0x33, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F}    // U+00FF (y umlaut)
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_0390
// Contains an 8x8 font map for unicode points U+0390 - U+03C9 (greek characters)
const uint8_t font8x8_greek[58][8] PROGMEM  = {
    { 0x2D, 0x00, 0x0C, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0390 (iota with tonos and diaeresis)
    { 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0391 (Alpha)
    { 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0392 (Beta)
    { 0x3F, 0x33, 0x03, 0x03, 0x03, 0x03, 0x03, 0x00},   // U+0393 (Gamma)
    { 0x08, 0x1C, 0x1C, 0x36, 0x36, 0x63, 0x7F, 0x00},   // U+0394 (Delta)
    { 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0395 (Epsilon)
    { 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+0396 (Zeta)
    { 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0397 (Eta)
    { 0x1C, 0x36, 0x63, 0x7F, 0x63, 0x36, 0x1C, 0x00},   // U+0398 (Theta)
    { 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0399 (Iota)
    { 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+039A (Kappa)
    { 0x08, 0x1C, 0x1C, 0x36, 0x36, 0x63, 0x63, 0x00},   // U+039B (Lambda)
    { 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+039C (Mu)
    { 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+039D (Nu)
    { 0x7F, 0x63, 0x00, 0x3E, 0x00, 0x63, 0x7F, 0x00},   // U+039E (Xi)
    { 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+039F (Omikron)
    { 0x7F, 0x36, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00},   // U+03A0 (Pi)
    { 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+03A1 (Rho)
    { 0x00, 0x01, 0x02, 0x04, 0x4F, 0x90, 0xA0, 0x40},   // U+03A2
    { 0x7F, 0x63, 0x06, 0x0C, 0x06, 0x63, 0x7F, 0x00},   // U+03A3 (Sigma 2)
    { 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+03A4 (Tau)
    { 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+03A5 (Upsilon)
    { 0x18, 0x7E, 0xDB, 0xDB, 0xDB, 0x7E, 0x18, 0x00},   // U+03A6 (Phi)
    { 0x63, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x63, 0x00},   // U+03A7 (Chi)
    { 0xDB, 0xDB, 0xDB, 0x7E, 0x18, 0x18, 0x3C, 0x00},   // U+03A8 (Psi)
    { 0x3E, 0x63, 0x63, 0x63, 0x36, 0x36, 0x77, 0x00},   // U+03A9 (Omega)
    { 0x33, 0x00, 0x1E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0399 (Iota with diaeresis)
    { 0x33, 0x00, 0x33, 0x33, 0x1E, 0x0C, 0x1E, 0x00},   // U+03A5 (Upsilon with diaeresis)
    { 0x70, 0x00, 0x6E, 0x3B, 0x13, 0x3B, 0x6E, 0x00},   // U+03AC (alpha aigu)
    { 0x38, 0x00, 0x1E, 0x03, 0x0E, 0x03, 0x1E, 0x00},   // U+03AD (epsilon aigu)
    { 0x38, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x30},   // U+03AE (eta aigu)
    { 0x38, 0x00, 0x0C, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+03AF (iota aigu)
    { 0x2D, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+03B0 (upsilon with tonos and diaeresis)
    { 0x00, 0x00, 0x6E, 0x3B, 0x13, 0x3B, 0x6E, 0x00},   // U+03B1 (alpha)
    { 0x00, 0x1E, 0x33, 0x1F, 0x33, 0x1F, 0x03, 0x03},   // U+03B2 (beta)
    { 0x00, 0x00, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x00},   // U+03B3 (gamma)
    { 0x38, 0x0C, 0x18, 0x3E, 0x33, 0x33, 0x1E, 0x00},   // U+03B4 (delta)
    { 0x00, 0x00, 0x1E, 0x03, 0x0E, 0x03, 0x1E, 0x00},   // U+03B5 (epsilon)
    { 0x00, 0x3F, 0x06, 0x03, 0x03, 0x1E, 0x30, 0x1C},   // U+03B6 (zeta)
    { 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x30},   // U+03B7 (eta)
    { 0x00, 0x00, 0x1E, 0x33, 0x3F, 0x33, 0x1E, 0x00},   // U+03B8 (theta)
    { 0x00, 0x00, 0x0C, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+03B9 (iota)
    { 0x00, 0x00, 0x33, 0x1B, 0x0F, 0x1B, 0x33, 0x00},   // U+03BA (kappa)
    { 0x00, 0x03, 0x06, 0x0C, 0x1C, 0x36, 0x63, 0x00},   // U+03BB (lambda)
    { 0x00, 0x00, 0x66, 0x66, 0x66, 0x3E, 0x06, 0x03},   // U+03BC (mu)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+03BD (nu)
    { 0x1E, 0x03, 0x0E, 0x03, 0x03, 0x1E, 0x30, 0x1C},   // U+03BE (xi)
    { 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+03BF (omikron)
    { 0x00, 0x00, 0x7F, 0x36, 0x36, 0x36, 0x36, 0x00},   // U+03C0 (pi)
    { 0x00, 0x00, 0x3C, 0x66, 0x66, 0x36, 0x06, 0x06},   // U+03C1 (rho)
    { 0x00, 0x00, 0x3E, 0x03, 0x03, 0x1E, 0x30, 0x1C},   // U+03C2 (sigma 1)
    { 0x00, 0x00, 0x7E, 0x1B, 0x1B, 0x1B, 0x0E, 0x00},   // U+03C3 (sigma 2)
    { 0x00, 0x00, 0x7E, 0x18, 0x18, 0x58, 0x30, 0x00},   // U+03C4 (tau)
    { 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+03C5 (upsilon)
    { 0x00, 0x00, 0x76, 0xDB, 0xDB, 0x7E, 0x18, 0x00},   // U+03C6 (phi)
    { 0x00, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+03C7 (chi)
    { 0x00, 0x00, 0xDB, 0xDB, 0xDB, 0x7E, 0x18, 0x00},   // U+03C8 (psi)
    { 0x00, 0x00, 0x36, 0x63, 0x6B, 0x7F, 0x36, 0x00}    // U+03C9 (omega)
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// for later use
const uint8_t font8x8_misc[10][8] PROGMEM = {
    { 0x1F, 0x33, 0x33, 0x5F, 0x63, 0xF3, 0x63, 0xE3},   // U+20A7 (Spanish Pesetas/Pt)
    { 0x70, 0xD8, 0x18, 0x3C, 0x18, 0x18, 0x1B, 0x0E},   // U+0192 (dutch florijn)
    { 0x3C, 0x36, 0x36, 0x7C, 0x00, 0x7E, 0x00, 0x00},   // U+ (underlined superscript a)
    { 0x1C, 0x36, 0x36, 0x1C, 0x00, 0x3E, 0x00, 0x00},   // U+ (underlined superscript 0)
    { 0x00, 0x00, 0x00, 0x3F, 0x03, 0x03, 0x00, 0x00},   // U+2310 (gun pointing right)
    { 0x30, 0x18, 0x0C, 0x18, 0x30, 0x00, 0x7E, 0x00},   // U+ (less than or equal)
    { 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x00, 0x7E, 0x00},   // U+ (greater than or equal)
    { 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+ (grave)
    { 0x0E, 0x00, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x00},   // U+ (Y grave)
    { 0x00, 0x07, 0x00, 0x33, 0x33, 0x3E, 0x30, 0x1F}    // U+ (y grave)
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_2500
// Contains an 8x8 font map for unicode points U+2500 - U+257F (box drawing)
const uint8_t font8x8_box[128][8] PROGMEM = {
    { 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00, 0x00, 0x00},   // U+2500 (thin horizontal)
    { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x00, 0x00, 0x00},   // U+2501 (thick horizontal)
    { 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08, 0x08},   // U+2502 (thin vertical)
    { 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18},   // U+2503 (thich vertical)
    { 0x00, 0x00, 0x00, 0x00, 0xBB, 0x00, 0x00, 0x00},   // U+2504 (thin horizontal dashed)
    { 0x00, 0x00, 0x00, 0xBB, 0xBB, 0x00, 0x00, 0x00},   // U+2505 (thick horizontal dashed)
    { 0x08, 0x00, 0x08, 0x08, 0x08, 0x00, 0x08, 0x08},   // U+2506 (thin vertical dashed)
    { 0x18, 0x00, 0x18, 0x18, 0x18, 0x00, 0x18, 0x18},   // U+2507 (thich vertical dashed)
    { 0x00, 0x00, 0x00, 0x00, 0x55, 0x00, 0x00, 0x00},   // U+2508 (thin horizontal dotted)
    { 0x00, 0x00, 0x00, 0x55, 0x55, 0x00, 0x00, 0x00},   // U+2509 (thick horizontal dotted)
    { 0x00, 0x08, 0x00, 0x08, 0x00, 0x08, 0x00, 0x08},   // U+250A (thin vertical dotted)
    { 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18},   // U+250B (thich vertical dotted)
    { 0x00, 0x00, 0x00, 0x00, 0xf8, 0x08, 0x08, 0x08},   // U+250C (down L, right L)
    { 0x00, 0x00, 0x00, 0xf8, 0xf8, 0x08, 0x08, 0x08},   // U+250D (down L, right H)
    { 0x00, 0x00, 0x00, 0x00, 0xf8, 0x18, 0x18, 0x18},   // U+250E (down H, right L)
    { 0x00, 0x00, 0x00, 0xf8, 0xf8, 0x18, 0x18, 0x18},   // U+250F (down H, right H)
    { 0x00, 0x00, 0x00, 0x00, 0x0f, 0x08, 0x08, 0x08},   // U+2510 (down L, left L)
    { 0x00, 0x00, 0x00, 0x0f, 0x0f, 0x08, 0x08, 0x08},   // U+2511 (down L, left H)
    { 0x00, 0x00, 0x00, 0x00, 0x1f, 0x18, 0x18, 0x18},   // U+2512 (down H, left L)
    { 0x00, 0x00, 0x00, 0x1f, 0x1f, 0x18, 0x18, 0x18},   // U+2513 (down H, left H)
    { 0x08, 0x08, 0x08, 0x08, 0xf8, 0x00, 0x00, 0x00},   // U+2514 (up L, right L)
    { 0x08, 0x08, 0x08, 0xf8, 0xf8, 0x00, 0x00, 0x00},   // U+2515 (up L, right H)
    { 0x18, 0x18, 0x18, 0x18, 0xf8, 0x00, 0x00, 0x00},   // U+2516 (up H, right L)
    { 0x18, 0x18, 0x18, 0xf8, 0xf8, 0x00, 0x00, 0x00},   // U+2517 (up H, right H)
    { 0x08, 0x08, 0x08, 0x08, 0x0f, 0x00, 0x00, 0x00},   // U+2518 (up L, left L)
    { 0x08, 0x08, 0x08, 0x0f, 0x0f, 0x00, 0x00, 0x00},   // U+2519 (up L, left H)
    { 0x18, 0x18, 0x18, 0x18, 0x1f, 0x00, 0x00, 0x00},   // U+251A (up H, left L)
    { 0x18, 0x18, 0x18, 0x1f, 0x1f, 0x00, 0x00, 0x00},   // U+251B (up H, left H)
    { 0x08, 0x08, 0x08, 0x08, 0xf8, 0x08, 0x08, 0x08},   // U+251C (down L, right L, up L)
    { 0x08, 0x08, 0x08, 0xf8, 0xf8, 0x08, 0x08, 0x08},   // U+251D (down L, right H, up L)
    { 0x18, 0x18, 0x18, 0x18, 0xf8, 0x08, 0x08, 0x08},   // U+251E (down L, right L, up H)
    { 0x08, 0x08, 0x08, 0x08, 0xf8, 0x18, 0x18, 0x18},   // U+251F (down H, right L, up L)
    { 0x18, 0x18, 0x18, 0x18, 0xf8, 0x18, 0x18, 0x18},   // U+2520 (down H, right L, up H)
    { 0x18, 0x18, 0x18, 0xf8, 0xf8, 0x08, 0x08, 0x08},   // U+2521 (down L, right H, up H)
    { 0x08, 0x08, 0x08, 0xf8, 0xf8, 0x18, 0x18, 0x18},   // U+2522 (down H, right H, up L)
    { 0x18, 0x18, 0x18, 0xf8, 0xf8, 0x18, 0x18, 0x18},   // U+2523 (down H, right H, up H)
    { 0x08, 0x08, 0x08, 0x08, 0x0f, 0x08, 0x08, 0x08},   // U+2524 (down L, left L, up L)
    { 0x08, 0x08, 0x08, 0x0f, 0x0f, 0x08, 0x08, 0x08},   // U+2525 (down L, left H, up L)
    { 0x18, 0x18, 0x18, 0x18, 0x1f, 0x08, 0x08, 0x08},   // U+2526 (down L, left L, up H)
    { 0x08, 0x08, 0x08, 0x08, 0x1f, 0x18, 0x18, 0x18},   // U+2527 (down H, left L, up L)
    { 0x18, 0x18, 0x18, 0x18, 0x1f, 0x18, 0x18, 0x18},   // U+2528 (down H, left L, up H)
    { 0x18, 0x18, 0x18, 0x1f, 0x1f, 0x08, 0x08, 0x08},   // U+2529 (down L, left H, up H)
    { 0x08, 0x08, 0x08, 0x1f, 0x1f, 0x18, 0x18, 0x18},   // U+252A (down H, left H, up L)
    { 0x18, 0x18, 0x18, 0x1f, 0x1f, 0x18, 0x18, 0x18},   // U+252B (down H, left H, up H)
    { 0x00, 0x00, 0x00, 0x00, 0xff, 0x08, 0x08, 0x08},   // U+252C (down L, right L, left L)
    { 0x00, 0x00, 0x00, 0x0f, 0xff, 0x08, 0x08, 0x08},   // U+252D (down L, right L, left H)
    { 0x00, 0x00, 0x00, 0xf8, 0xff, 0x08, 0x08, 0x08},   // U+252E (down L, right H, left L)
    { 0x00, 0x00, 0x00, 0xff, 0xff, 0x08, 0x08, 0x08},   // U+252F (down L, right H, left H)
    { 0x00, 0x00, 0x00, 0x00, 0xff, 0x18, 0x18, 0x18},   // U+2530 (down H, right L, left L)
    { 0x00, 0x00, 0x00, 0x1f, 0xff, 0x18, 0x18, 0x18},   // U+2531 (down H, right L, left H)
    { 0x00, 0x00, 0x00, 0xf8, 0xff, 0x18, 0x18, 0x18},   // U+2532 (down H, right H, left L)
    { 0x00, 0x00, 0x00, 0xff, 0xff, 0x18, 0x18, 0x18},   // U+2533 (down H, right H, left H)
    { 0x08, 0x08, 0x08, 0x08, 0xff, 0x00, 0x00, 0x00},   // U+2534 (up L, right L, left L)
    { 0x08, 0x08, 0x08, 0x0f, 0xff, 0x00, 0x00, 0x00},   // U+2535 (up L, right L, left H)
    { 0x08, 0x08, 0x08, 0xf8, 0xff, 0x00, 0x00, 0x00},   // U+2536 (up L, right H, left L)
    { 0x08, 0x08, 0x08, 0xff, 0xff, 0x00, 0x00, 0x00},   // U+2537 (up L, right H, left H)
    { 0x18, 0x18, 0x18, 0x18, 0xff, 0x00, 0x00, 0x00},   // U+2538 (up H, right L, left L)
    { 0x18, 0x18, 0x18, 0x1f, 0xff, 0x00, 0x00, 0x00},   // U+2539 (up H, right L, left H)
    { 0x18, 0x18, 0x18, 0xf8, 0xff, 0x00, 0x00, 0x00},   // U+253A (up H, right H, left L)
    { 0x18, 0x18, 0x18, 0xff, 0xff, 0x00, 0x00, 0x00},   // U+253B (up H, right H, left H)
    { 0x08, 0x08, 0x08, 0x08, 0xff, 0x08, 0x08, 0x08},   // U+253C (up L, right L, left L, down L)
    { 0x08, 0x08, 0x08, 0x0f, 0xff, 0x08, 0x08, 0x08},   // U+253D (up L, right L, left H, down L)
    { 0x08, 0x08, 0x08, 0xf8, 0xff, 0x08, 0x08, 0x08},   // U+253E (up L, right H, left L, down L)
    { 0x08, 0x08, 0x08, 0xff, 0xff, 0x08, 0x08, 0x08},   // U+253F (up L, right H, left H, down L)
    { 0x18, 0x18, 0x18, 0x18, 0xff, 0x08, 0x08, 0x08},   // U+2540 (up H, right L, left L, down L)
    { 0x08, 0x08, 0x08, 0x08, 0xff, 0x18, 0x18, 0x18},   // U+2541 (up L, right L, left L, down H)
    { 0x18, 0x18, 0x18, 0x18, 0xff, 0x18, 0x18, 0x18},   // U+2542 (up H, right L, left L, down H)
    { 0x18, 0x18, 0x18, 0x1f, 0xff, 0x08, 0x08, 0x08},   // U+2543 (up H, right L, left H, down L)
    { 0x18, 0x18, 0x18, 0xf8, 0xff, 0x08, 0x08, 0x08},   // U+2544 (up H, right H, left L, down L)
    { 0x08, 0x08, 0x08, 0x1f, 0xff, 0x18, 0x18, 0x18},   // U+2545 (up L, right L, left H, down H)
    { 0x08, 0x08, 0x08, 0xf8, 0xff, 0x18, 0x18, 0x18},   // U+2546 (up L, right H, left L, down H)
    { 0x08, 0x08, 0x08, 0xff, 0xff, 0x18, 0x18, 0x18},   // U+2547 (up L, right H, left H, down H)
    { 0x18, 0x18, 0x18, 0xff, 0xff, 0x08, 0x08, 0x08},   // U+254B (up H, right H, left H, down L)
    { 0x18, 0x18, 0x18, 0xf8, 0xff, 0x18, 0x18, 0x18},   // U+254A (up H, right H, left L, down H)
    { 0x18, 0x18, 0x18, 0x1f, 0xff, 0x18, 0x18, 0x18},   // U+2549 (up H, right L, left H, down H)
    { 0x18, 0x18, 0x18, 0xff, 0xff, 0x18, 0x18, 0x18},   // U+254B (up H, right H, left H, down H)
    { 0x00, 0x00, 0x00, 0x00, 0xE7, 0x00, 0x00, 0x00},   // U+254C (thin horizontal broken)
    { 0x00, 0x00, 0x00, 0xE7, 0xE7, 0x00, 0x00, 0x00},   // U+254D (thick horizontal broken)
    { 0x08, 0x08, 0x08, 0x00, 0x00, 0x08, 0x08, 0x08},   // U+254E (thin vertical broken)
    { 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x18, 0x18},   // U+254F (thich vertical broken)
    { 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x00, 0x00},   // U+2550 (double horizontal)
    { 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14, 0x14},   // U+2551 (double vertical)
    { 0x00, 0x00, 0x00, 0xF8, 0x08, 0xF8, 0x08, 0x08},   // U+2552 (down L, right D)
    { 0x00, 0x00, 0x00, 0x00, 0xFC, 0x14, 0x14, 0x14},   // U+2553 (down D, right L)
    { 0x00, 0x00, 0x00, 0xFC, 0x04, 0xF4, 0x14, 0x14},   // U+2554 (down D, right D)
    { 0x00, 0x00, 0x00, 0x0F, 0x08, 0x0F, 0x08, 0x08},   // U+2555 (down L, left D)
    { 0x00, 0x00, 0x00, 0x00, 0x1F, 0x14, 0x14, 0x14},   // U+2556 (down D, left L)
    { 0x00, 0x00, 0x00, 0x1F, 0x10, 0x17, 0x14, 0x14},   // U+2557 (down D, left D)
    { 0x08, 0x08, 0x08, 0xF8, 0x08, 0xF8, 0x00, 0x00},   // U+2558 (up L, right D)
    { 0x14, 0x14, 0x14, 0x14, 0xFC, 0x00, 0x00, 0x00},   // U+2559 (up D, right L)
    { 0x14, 0x14, 0x14, 0xF4, 0x04, 0xFC, 0x00, 0x00},   // U+255A (up D, right D)
    { 0x08, 0x08, 0x08, 0x0F, 0x08, 0x0F, 0x00, 0x00},   // U+255B (up L, left D)
    { 0x14, 0x14, 0x14, 0x14, 0x1F, 0x00, 0x00, 0x00},   // U+255C (up D, left L)
    { 0x14, 0x14, 0x14, 0x17, 0x10, 0x1F, 0x00, 0x00},   // U+255D (up D, left D)
    { 0x08, 0x08, 0x08, 0xF8, 0x08, 0xF8, 0x08, 0x08},   // U+255E (up L, down L, right D)
    { 0x14, 0x14, 0x14, 0x14, 0xF4, 0x14, 0x14, 0x14},   // U+255F (up D, down D, right L)
    { 0x14, 0x14, 0x14, 0xF4, 0x04, 0xF4, 0x14, 0x14},   // U+2560 (up D, down D, right D)
    { 0x08, 0x08, 0x08, 0x0F, 0x08, 0x0F, 0x08, 0x08},   // U+2561 (up L, down L, left D)
    { 0x14, 0x14, 0x14, 0x14, 0x17, 0x14, 0x14, 0x14},   // U+2562 (up D, down D, left L)
    { 0x14, 0x14, 0x14, 0x17, 0x10, 0x17, 0x14, 0x14},   // U+2563 (up D, down D, left D)
    { 0x00, 0x00, 0x00, 0xFF, 0x00, 0xFF, 0x08, 0x08},   // U+2564 (left D, right D, down L)
    { 0x00, 0x00, 0x00, 0x00, 0xFF, 0x14, 0x14, 0x14},   // U+2565 (left L, right L, down D)
    { 0x00, 0x00, 0x00, 0xFF, 0x00, 0xF7, 0x14, 0x14},   // U+2566 (left D, right D, down D)
    { 0x08, 0x08, 0x08, 0xFF, 0x00, 0xFF, 0x00, 0x00},   // U+2567 (left D, right D, up L)
    { 0x14, 0x14, 0x14, 0x14, 0xFF, 0x00, 0x00, 0x00},   // U+2568 (left L, right L, up D)
    { 0x14, 0x14, 0x14, 0xF7, 0x00, 0xFF, 0x00, 0x00},   // U+2569 (left D, right D, up D)
    { 0x08, 0x08, 0x08, 0xFF, 0x08, 0xFF, 0x08, 0x08},   // U+256A (left D, right D, down L, up L)
    { 0x14, 0x14, 0x14, 0x14, 0xFF, 0x14, 0x14, 0x14},   // U+256B (left L, right L, down D, up D)
    { 0x14, 0x14, 0x14, 0xF7, 0x00, 0xF7, 0x14, 0x14},   // U+256C (left D, right D, down D, up D)
    { 0x00, 0x00, 0x00, 0x00, 0xE0, 0x10, 0x08, 0x08},   // U+256D (curve down-right)
    { 0x00, 0x00, 0x00, 0x00, 0x03, 0x04, 0x08, 0x08},   // U+256E (curve down-left)
    { 0x08, 0x08, 0x08, 0x04, 0x03, 0x00, 0x00, 0x00},   // U+256F (curve up-left)
    { 0x08, 0x08, 0x08, 0x10, 0xE0, 0x00, 0x00, 0x00},   // U+2570 (curve up-right)
    { 0x80, 0x40, 0x20, 0x10, 0x08, 0x04, 0x02, 0x01},   // U+2571 (diagonal bottom-left to top-right)
    { 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80},   // U+2572 (diagonal bottom-right to top-left)
    { 0x81, 0x42, 0x24, 0x18, 0x18, 0x24, 0x42, 0x81},   // U+2573 (diagonal cross)
    { 0x00, 0x00, 0x00, 0x00, 0x0F, 0x00, 0x00, 0x00},   // U+2574 (left L)
    { 0x08, 0x08, 0x08, 0x08, 0x00, 0x00, 0x00, 0x00},   // U+2575 (up L)
    { 0x00, 0x00, 0x00, 0x00, 0xF8, 0x00, 0x00, 0x00},   // U+2576 (right L)
    { 0x00, 0x00, 0x00, 0x00, 0x08, 0x08, 0x08, 0x08},   // U+2577 (down L)
    { 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x00, 0x00, 0x00},   // U+2578 (left H)
    { 0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x00, 0x00},   // U+2579 (up H)
    { 0x00, 0x00, 0x00, 0xF8, 0xF8, 0x00, 0x00, 0x00},   // U+257A (right H)
    { 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x18, 0x18},   // U+257B (down H)
    { 0x00, 0x00, 0x00, 0xF8, 0xFF, 0x00, 0x00, 0x00},   // U+257C (right H, left L)
    { 0x08, 0x08, 0x08, 0x08, 0x18, 0x18, 0x18, 0x18},   // U+257D (up L, down H)
    { 0x00, 0x00, 0x00, 0x0F, 0xFF, 0x00, 0x00, 0x00},   // U+257E (right L, left H)
    { 0x18, 0x18, 0x18, 0x18, 0x08, 0x08, 0x08, 0x08}    // U+257F (up H, down L)
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Constant: font8x8_2580
// Contains an 8x8 font map for unicode points U+2580 - U+259F (block elements)
const uint8_t font8x8_block[32][8] PROGMEM = {
    { 0xFF, 0xFF, 0xFF, 0xFF, 0x00, 0x00, 0x00, 0x00},   // U+2580 (top half)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+2581 (box 1/8)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF},   // U+2582 (box 2/8)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF},   // U+2583 (box 3/8)
    { 0x00, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2584 (bottom half)
    { 0x00, 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2585 (box 5/8)
    { 0x00, 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2586 (box 6/8)
    { 0x00, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2587 (box 7/8)
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2588 (solid)
    { 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F, 0x7F},   // U+2589 (box 7/8)
    { 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F, 0x3F},   // U+258A (box 6/8)
    { 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F, 0x1F},   // U+258B (box 5/8)
    { 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F, 0x0F},   // U+258C (left half)
    { 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07, 0x07},   // U+258D (box 3/8)
    { 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03, 0x03},   // U+258E (box 2/8)
    { 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01, 0x01},   // U+258F (box 1/8)
    { 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0, 0xF0},   // U+2590 (right half)
    { 0x55, 0x00, 0xAA, 0x00, 0x55, 0x00, 0xAA, 0x00},   // U+2591 (25% solid)
    { 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA, 0x55, 0xAA},   // U+2592 (50% solid)
    { 0xFF, 0xAA, 0xFF, 0x55, 0xFF, 0xAA, 0xFF, 0x55},   // U+2593 (75% solid)
    { 0xFF, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+2594 (box 1/8)
    { 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80, 0x80},   // U+2595 (box 1/8)
    { 0x00, 0x00, 0x00, 0x00, 0x0F, 0x0F, 0x0F, 0x0F},   // U+2596 (box bottom left)
    { 0x00, 0x00, 0x00, 0x00, 0xF0, 0xF0, 0xF0, 0xF0},   // U+2597 (box bottom right)
    { 0x0F, 0x0F, 0x0F, 0x0F, 0x00, 0x00, 0x00, 0x00},   // U+2598 (box top left)
    { 0x0F, 0x0F, 0x0F, 0x0F, 0xFF, 0xFF, 0xFF, 0xFF},   // U+2599 (boxes left and bottom)
    { 0x0F, 0x0F, 0x0F, 0x0F, 0xF0, 0xF0, 0xF0, 0xF0},   // U+259A (boxes top-left and bottom right)
    { 0xFF, 0xFF, 0xFF, 0xFF, 0x0F, 0x0F, 0x0F, 0x0F},   // U+259B (boxes top and left)
    { 0xFF, 0xFF, 0xFF, 0xFF, 0xF0, 0xF0, 0xF0, 0xF0},   // U+259C (boxes top and right)
    { 0xF0, 0xF0, 0xF0, 0xF0, 0x00, 0x00, 0x00, 0x00},   // U+259D (box top right)
    { 0xF0, 0xF0, 0xF0, 0xF0, 0x0F, 0x0F, 0x0F, 0x0F},   // U+259E (boxes top right and bottom left)
    { 0xF0, 0xF0, 0xF0, 0xF0, 0xFF, 0xFF, 0xFF, 0xFF},   // U+259F (boxes right and bottom)
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

// Contains an 8x8 font map for unicode points U+3040 - U+309F (Hiragana)
// Constant: font8x8_3040
const uint8_t font8x8_hiragana[96][8] PROGMEM = {
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3040
    { 0x04, 0x3F, 0x04, 0x3C, 0x56, 0x4D, 0x26, 0x00},   // U+3041 (Hiragana a)
    { 0x04, 0x3F, 0x04, 0x3C, 0x56, 0x4D, 0x26, 0x00},   // U+3042 (Hiragana A)
    { 0x00, 0x00, 0x00, 0x11, 0x21, 0x25, 0x02, 0x00},   // U+3043 (Hiragana i)
    { 0x00, 0x01, 0x11, 0x21, 0x21, 0x25, 0x02, 0x00},   // U+3044 (Hiragana I)
    { 0x00, 0x1C, 0x00, 0x1C, 0x22, 0x20, 0x18, 0x00},   // U+3045 (Hiragana u)
    { 0x3C, 0x00, 0x3C, 0x42, 0x40, 0x20, 0x18, 0x00},   // U+3046 (Hiragana U)
    { 0x1C, 0x00, 0x3E, 0x10, 0x38, 0x24, 0x62, 0x00},   // U+3047 (Hiragana e)
    { 0x1C, 0x00, 0x3E, 0x10, 0x38, 0x24, 0x62, 0x00},   // U+3048 (Hiragana E)
    { 0x24, 0x4F, 0x04, 0x3C, 0x46, 0x45, 0x22, 0x00},   // U+3049 (Hiragana o)
    { 0x24, 0x4F, 0x04, 0x3C, 0x46, 0x45, 0x22, 0x00},   // U+304A (Hiragana O)
    { 0x04, 0x24, 0x4F, 0x54, 0x52, 0x12, 0x09, 0x00},   // U+304B (Hiragana KA)
    { 0x44, 0x24, 0x0F, 0x54, 0x52, 0x52, 0x09, 0x00},   // U+304C (Hiragana GA)
    { 0x08, 0x1F, 0x08, 0x3F, 0x1C, 0x02, 0x3C, 0x00},   // U+304D (Hiragana KI)
    { 0x44, 0x2F, 0x04, 0x1F, 0x0E, 0x01, 0x1E, 0x00},   // U+304E (Hiragana GI)
    { 0x10, 0x08, 0x04, 0x02, 0x04, 0x08, 0x10, 0x00},   // U+304F (Hiragana KU)
    { 0x28, 0x44, 0x12, 0x21, 0x02, 0x04, 0x08, 0x00},   // U+3050 (Hiragana GU)
    { 0x00, 0x22, 0x79, 0x21, 0x21, 0x22, 0x10, 0x00},   // U+3051 (Hiragana KE)
    { 0x40, 0x22, 0x11, 0x3D, 0x11, 0x12, 0x08, 0x00},   // U+3052 (Hiragana GE)
    { 0x00, 0x00, 0x3C, 0x00, 0x02, 0x02, 0x3C, 0x00},   // U+3053 (Hiragana KO)
    { 0x20, 0x40, 0x16, 0x20, 0x01, 0x01, 0x0E, 0x00},   // U+3054 (Hiragana GO)
    { 0x10, 0x7E, 0x10, 0x3C, 0x02, 0x02, 0x1C, 0x00},   // U+3055 (Hiragana SA)
    { 0x24, 0x4F, 0x14, 0x2E, 0x01, 0x01, 0x0E, 0x00},   // U+3056 (Hiragana ZA)
    { 0x00, 0x02, 0x02, 0x02, 0x42, 0x22, 0x1C, 0x00},   // U+3057 (Hiragana SI)
    { 0x20, 0x42, 0x12, 0x22, 0x02, 0x22, 0x1C, 0x00},   // U+3058 (Hiragana ZI)
    { 0x10, 0x7E, 0x18, 0x14, 0x18, 0x10, 0x0C, 0x00},   // U+3059 (Hiragana SU)
    { 0x44, 0x2F, 0x06, 0x05, 0x06, 0x04, 0x03, 0x00},   // U+305A (Hiragana ZU)
    { 0x20, 0x72, 0x2F, 0x22, 0x1A, 0x02, 0x1C, 0x00},   // U+305B (Hiragana SE)
    { 0x80, 0x50, 0x3A, 0x17, 0x1A, 0x02, 0x1C, 0x00},   // U+305C (Hiragana ZE)
    { 0x1E, 0x08, 0x04, 0x7F, 0x08, 0x04, 0x38, 0x00},   // U+305D (Hiragana SO)
    { 0x4F, 0x24, 0x02, 0x7F, 0x08, 0x04, 0x38, 0x00},   // U+305E (Hiragana ZO)
    { 0x02, 0x0F, 0x02, 0x72, 0x02, 0x09, 0x71, 0x00},   // U+305F (Hiragana TA)
    { 0x42, 0x2F, 0x02, 0x72, 0x02, 0x09, 0x71, 0x00},   // U+3060 (Hiragana DA)
    { 0x08, 0x7E, 0x08, 0x3C, 0x40, 0x40, 0x38, 0x00},   // U+3061 (Hiragana TI)
    { 0x44, 0x2F, 0x04, 0x1E, 0x20, 0x20, 0x1C, 0x00},   // U+3062 (Hiragana DI)
    { 0x00, 0x00, 0x00, 0x1C, 0x22, 0x20, 0x1C, 0x00},   // U+3063 (Hiragana tu)
    { 0x00, 0x1C, 0x22, 0x41, 0x40, 0x20, 0x1C, 0x00},   // U+3064 (Hiragana TU)
    { 0x40, 0x20, 0x1E, 0x21, 0x20, 0x20, 0x1C, 0x00},   // U+3065 (Hiragana DU)
    { 0x00, 0x3E, 0x08, 0x04, 0x04, 0x04, 0x38, 0x00},   // U+3066 (Hiragana TE)
    { 0x00, 0x3E, 0x48, 0x24, 0x04, 0x04, 0x38, 0x00},   // U+3067 (Hiragana DE)
    { 0x04, 0x04, 0x08, 0x3C, 0x02, 0x02, 0x3C, 0x00},   // U+3068 (Hiragana TO)
    { 0x44, 0x24, 0x08, 0x3C, 0x02, 0x02, 0x3C, 0x00},   // U+3069 (Hiragana DO)
    { 0x32, 0x02, 0x27, 0x22, 0x72, 0x29, 0x11, 0x00},   // U+306A (Hiragana NA)
    { 0x00, 0x02, 0x7A, 0x02, 0x0A, 0x72, 0x02, 0x00},   // U+306B (Hiragana NI)
    { 0x08, 0x09, 0x3E, 0x4B, 0x65, 0x55, 0x22, 0x00},   // U+306C (Hiragana NU)
    { 0x04, 0x07, 0x34, 0x4C, 0x66, 0x54, 0x24, 0x00},   // U+306D (Hiragana NE)
    { 0x00, 0x00, 0x3C, 0x4A, 0x49, 0x45, 0x22, 0x00},   // U+306E (Hiragana NO)
    { 0x00, 0x22, 0x7A, 0x22, 0x72, 0x2A, 0x12, 0x00},   // U+306F (Hiragana HA)
    { 0x80, 0x51, 0x1D, 0x11, 0x39, 0x15, 0x09, 0x00},   // U+3070 (Hiragana BA)
    { 0x40, 0xB1, 0x5D, 0x11, 0x39, 0x15, 0x09, 0x00},   // U+3071 (Hiragana PA)
    { 0x00, 0x00, 0x13, 0x32, 0x51, 0x11, 0x0E, 0x00},   // U+3072 (Hiragana HI)
    { 0x40, 0x20, 0x03, 0x32, 0x51, 0x11, 0x0E, 0x00},   // U+3073 (Hiragana BI)
    { 0x40, 0xA0, 0x43, 0x32, 0x51, 0x11, 0x0E, 0x00},   // U+3074 (Hiragana PI)
    { 0x1C, 0x00, 0x08, 0x2A, 0x49, 0x10, 0x0C, 0x00},   // U+3075 (Hiragana HU)
    { 0x4C, 0x20, 0x08, 0x2A, 0x49, 0x10, 0x0C, 0x00},   // U+3076 (Hiragana BU)
    { 0x4C, 0xA0, 0x48, 0x0A, 0x29, 0x48, 0x0C, 0x00},   // U+3077 (Hiragana PU)
    { 0x00, 0x00, 0x04, 0x0A, 0x11, 0x20, 0x40, 0x00},   // U+3078 (Hiragana HE)
    { 0x20, 0x40, 0x14, 0x2A, 0x11, 0x20, 0x40, 0x00},   // U+3079 (Hiragana BE)
    { 0x20, 0x50, 0x24, 0x0A, 0x11, 0x20, 0x40, 0x00},   // U+307A (Hiragana PE)
    { 0x7D, 0x11, 0x7D, 0x11, 0x39, 0x55, 0x09, 0x00},   // U+307B (Hiragana HO)
    { 0x9D, 0x51, 0x1D, 0x11, 0x39, 0x55, 0x09, 0x00},   // U+307C (Hiragana BO)
    { 0x5D, 0xB1, 0x5D, 0x11, 0x39, 0x55, 0x09, 0x00},   // U+307D (Hiragana PO)
    { 0x7E, 0x08, 0x3E, 0x08, 0x1C, 0x2A, 0x04, 0x00},   // U+307E (Hiragana MA)
    { 0x00, 0x07, 0x24, 0x24, 0x7E, 0x25, 0x12, 0x00},   // U+307F (Hiragana MI)
    { 0x04, 0x0F, 0x64, 0x06, 0x05, 0x26, 0x3C, 0x00},   // U+3080 (Hiragana MU)
    { 0x00, 0x09, 0x3D, 0x4A, 0x4B, 0x45, 0x2A, 0x00},   // U+3081 (Hiragana ME)
    { 0x02, 0x0F, 0x02, 0x0F, 0x62, 0x42, 0x3C, 0x00},   // U+3082 (Hiragana MO)
    { 0x00, 0x00, 0x12, 0x1F, 0x22, 0x12, 0x04, 0x00},   // U+3083 (Hiragana ya)
    { 0x00, 0x12, 0x3F, 0x42, 0x42, 0x34, 0x04, 0x00},   // U+3084 (Hiragana YA)
    { 0x00, 0x00, 0x11, 0x3D, 0x53, 0x39, 0x11, 0x00},   // U+3085 (Hiragana yu)
    { 0x00, 0x11, 0x3D, 0x53, 0x51, 0x39, 0x11, 0x00},   // U+3086 (Hiragana YU)
    { 0x00, 0x08, 0x38, 0x08, 0x1C, 0x2A, 0x04, 0x00},   // U+3087 (Hiragana yo)
    { 0x08, 0x08, 0x38, 0x08, 0x1C, 0x2A, 0x04, 0x00},   // U+3088 (Hiragana YO)
    { 0x1E, 0x00, 0x02, 0x3A, 0x46, 0x42, 0x30, 0x00},   // U+3089 (Hiragana RA)
    { 0x00, 0x20, 0x22, 0x22, 0x2A, 0x24, 0x10, 0x00},   // U+308A (Hiragana RI)
    { 0x1F, 0x08, 0x3C, 0x42, 0x49, 0x54, 0x38, 0x00},   // U+308B (Hiragana RU)
    { 0x04, 0x07, 0x04, 0x0C, 0x16, 0x55, 0x24, 0x00},   // U+308C (Hiragana RE)
    { 0x3F, 0x10, 0x08, 0x3C, 0x42, 0x41, 0x30, 0x00},   // U+308D (Hiragana RO)
    { 0x00, 0x00, 0x08, 0x0E, 0x38, 0x4C, 0x2A, 0x00},   // U+308E (Hiragana wa)
    { 0x04, 0x07, 0x04, 0x3C, 0x46, 0x45, 0x24, 0x00},   // U+308F (Hiragana WA)
    { 0x0E, 0x08, 0x3C, 0x4A, 0x69, 0x55, 0x32, 0x00},   // U+3090 (Hiragana WI)
    { 0x06, 0x3C, 0x42, 0x39, 0x04, 0x36, 0x49, 0x00},   // U+3091 (Hiragana WE)
    { 0x04, 0x0F, 0x04, 0x6E, 0x11, 0x08, 0x70, 0x00},   // U+3092 (Hiragana WO)
    { 0x08, 0x08, 0x04, 0x0C, 0x56, 0x52, 0x21, 0x00},   // U+3093 (Hiragana N)
    { 0x40, 0x2E, 0x00, 0x3C, 0x42, 0x40, 0x38, 0x00},   // U+3094 (Hiragana VU)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3095
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3096
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3097
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3098
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+3099 (voiced combinator mark)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+309A (semivoiced combinator mark)
    { 0x40, 0x80, 0x20, 0x40, 0x00, 0x00, 0x00, 0x00},   // U+309B (Hiragana voiced mark)
    { 0x40, 0xA0, 0x40, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+309C (Hiragana semivoiced mark)
    { 0x00, 0x00, 0x08, 0x08, 0x10, 0x30, 0x0C, 0x00},   // U+309D (Hiragana iteration mark)
    { 0x20, 0x40, 0x14, 0x24, 0x08, 0x18, 0x06, 0x00},   // U+309E (Hiragana voiced iteration mark)
    { 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00}    // U+309F
};

/** 
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 * 
 * License: Public Domain
 * 
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 * 
 * Fetched from: http://dimensionalrift.homelinux.net/combuster/mos3/?p=viewsource&file=/modules/gfx/font8_8.asm
 **/

const uint8_t font8x8_sga[26][8] PROGMEM = {
    { 0x00, 0x00, 0x38, 0x66, 0x06, 0x06, 0x07, 0x00},   // U+E541 (SGA A)
    { 0x00, 0x00, 0x0C, 0x0C, 0x18, 0x30, 0x7F, 0x00},   // U+E542 (SGA B)
    { 0x00, 0x00, 0x0C, 0x00, 0x0C, 0x30, 0x30, 0x00},   // U+E543 (SGA C)
    { 0x00, 0x00, 0x7F, 0x00, 0x03, 0x1C, 0x60, 0x00},   // U+E544 (SGA D)
    { 0x00, 0x00, 0x63, 0x03, 0x03, 0x03, 0x7F, 0x00},   // U+E545 (SGA E)
    { 0x00, 0x00, 0x00, 0xFF, 0x00, 0xDB, 0x00, 0x00},   // U+E546 (SGA F)
    { 0x00, 0x00, 0x30, 0x30, 0x3E, 0x30, 0x30, 0x00},   // U+E547 (SGA G)
    { 0x00, 0x00, 0x7E, 0x00, 0x7E, 0x18, 0x18, 0x00},   // U+E548 (SGA H)
    { 0x00, 0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00},   // U+E549 (SGA I)
    { 0x00, 0x00, 0x18, 0x00, 0x18, 0x00, 0x18, 0x00},   // U+E54A (SGA J)
    { 0x00, 0x00, 0x18, 0x18, 0x5A, 0x18, 0x18, 0x00},   // U+E54B (SGA K)
    { 0x00, 0x00, 0x03, 0x33, 0x03, 0x33, 0x03, 0x00},   // U+E54C (SGA L)
    { 0x00, 0x00, 0x63, 0x60, 0x60, 0x60, 0x7F, 0x00},   // U+E54D (SGA M)
    { 0x00, 0x00, 0x66, 0x60, 0x30, 0x18, 0x0C, 0x00},   // U+E54E (SGA N)
    { 0x00, 0x00, 0x3C, 0x60, 0x30, 0x18, 0x0C, 0x00},   // U+E54F (SGA O)
    { 0x00, 0x00, 0x66, 0x60, 0x66, 0x06, 0x66, 0x00},   // U+E550 (SGA P)
    { 0x00, 0x00, 0x18, 0x00, 0x7E, 0x60, 0x7E, 0x00},   // U+E551 (SGA Q)
    { 0x00, 0x00, 0x00, 0x66, 0x00, 0x66, 0x00, 0x00},   // U+E552 (SGA R)
    { 0x00, 0x00, 0x0C, 0x0C, 0x3C, 0x30, 0x30, 0x00},   // U+E553 (SGA S)
    { 0x00, 0x00, 0x3C, 0x30, 0x30, 0x00, 0x30, 0x00},   // U+E554 (SGA T)
    { 0x00, 0x00, 0x00, 0x36, 0x00, 0x7F, 0x00, 0x00},   // U+E555 (SGA U)
    { 0x00, 0x00, 0x18, 0x18, 0x7E, 0x00, 0x7E, 0x00},   // U+E556 (SGA V)
    { 0x00, 0x00, 0x00, 0x18, 0x00, 0x66, 0x00, 0x00},   // U+E557 (SGA W)
    { 0x00, 0x00, 0x66, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+E558 (SGA X)
    { 0x00, 0x00, 0x36, 0x36, 0x36, 0x36, 0x36, 0x00},   // U+E559 (SGA Y)
    { 0x00, 0x00, 0x18, 0x3C, 0x66, 0x66, 0x66, 0x00}    // U+E55A (SGA Z)
};



#define I2C_ADDR_BASE               0b01100000
#define I2C_ADDR_ALT0               0b01100000
#define I2C_ADDR_ALT1               0b01100001
#define I2C_ADDR_ALT2               0b01100010
#define I2C_ADDR_ALT3               0b01100011
#define I2C_ADDR_MASK               0b00000011

#define MATRIX_SIZE_8X8             0b0000
#define MATRIX_SIZE_7X9             0b0001
#define MATRIX_SIZE_6X10            0b0010
#define MATRIX_SIZE_5X11            0b0011
#define MATRIX_SIZE_MASK            0b0011

#define MATRIX_MIN_ROWS             8
#define MATRIX_MAX_ROWS             11
#define MATRIX_MIN_COLS             5
#define MATRIX_MAX_COLS             8

#define AUDIO_GAIN_0DB              0b0000
#define AUDIO_GAIN_3DB              0b0001
#define AUDIO_GAIN_6DB              0b0010
#define AUDIO_GAIN_9DB              0b0011
#define AUDIO_GAIN_12DB             0b0100
#define AUDIO_GAIN_15DB             0b0101
#define AUDIO_GAIN_18DB             0b0110
#define AUDIO_GAIN_M6DB             0b0111
#define AUDIO_GAIN_MASK             0b0111

#define ROW_CURRENT_40MA            0b0000
#define ROW_CURRENT_45MA            0b0001
#define ROW_CURRENT_50MA            0b0010
#define ROW_CURRENT_55MA            0b0011
#define ROW_CURRENT_60MA            0b0100
#define ROW_CURRENT_65MA            0b0101
#define ROW_CURRENT_70MA            0b0110
#define ROW_CURRENT_75MA            0b0111
#define ROW_CURRENT_05MA            0b1000
#define ROW_CURRENT_10MA            0b1001
#define ROW_CURRENT_15MA            0b1010
#define ROW_CURRENT_20MA            0b1011
#define ROW_CURRENT_25MA            0b1100
#define ROW_CURRENT_30MA            0b1101
#define ROW_CURRENT_35MA            0b1110
#define ROW_CURRENT_XXMA            0b1111
#define ROW_CURRENT_MASK            0b1111

#define REG_ADDR_CONFIGURATION      0x00
#define REG_ADDR_COLUMN_DATA        0x01
#define REG_ADDR_UPDATE_COLUMN      0x0C
#define REG_ADDR_LIGHTING_EFFECT    0x0D
#define REG_ADDR_AUDIO_EQUALIZER    0x0F

#define BIT_CONFIG_SSD              7
#define BIT_CONFIG_AUDIO_EN         2
#define BIT_CONFIG_ADM              0

#define BIT_EFFECT_AUDIO_GAIN       4
#define BIT_EFFECT_ROW_CURRENT      0

#define BIT_AUDIO_EQ_EN             6

#define FONT_8X8_BASIC              0
#define FONT_8X8_CONTROL            1
#define FONT_8X8_EXT_LATIN          2
#define FONT_8X8_GREEK              3
#define FONT_8X8_MISC               4
#define FONT_8X8_BOX                5
#define FONT_8X8_BLOCK              6
#define FONT_8X8_HIRAGANA           7
#define FONT_8X8_SGA                8

#define ROTATION_0                  0
#define ROTATION_90                 1
#define ROTATION_180                2
#define ROTATION_270                3

const uint8_t PROGMEM RER_BIT_MAP[256] = {  0x00, 0x80, 0x40, 0xC0, 0x20, 0xA0, 0x60, 0xE0, 0x10, 0x90, 0x50, 0xD0, 0x30, 0xB0, 0x70, 0xF0,
                                            0x08, 0x88, 0x48, 0xC8, 0x28, 0xA8, 0x68, 0xE8, 0x18, 0x98, 0x58, 0xD8, 0x38, 0xB8, 0x78, 0xF8, 
                                            0x04, 0x84, 0x44, 0xC4, 0x24, 0xA4, 0x64, 0xE4, 0x14, 0x94, 0x54, 0xD4, 0x34, 0xB4, 0x74, 0xF4,
                                            0x0C, 0x8C, 0x4C, 0xCC, 0x2C, 0xAC, 0x6C, 0xEC, 0x1C, 0x9C, 0x5C, 0xDC, 0x3C, 0xBC, 0x7C, 0xFC,
                                            0x02, 0x82, 0x42, 0xC2, 0x22, 0xA2, 0x62, 0xE2, 0x12, 0x92, 0x52, 0xD2, 0x32, 0xB2, 0x72, 0xF2,
                                            0x0A, 0x8A, 0x4A, 0xCA, 0x2A, 0xAA, 0x6A, 0xEA, 0x1A, 0x9A, 0x5A, 0xDA, 0x3A, 0xBA, 0x7A, 0xFA,
                                            0x06, 0x86, 0x46, 0xC6, 0x26, 0xA6, 0x66, 0xE6, 0x16, 0x96, 0x56, 0xD6, 0x36, 0xB6, 0x76, 0xF6,
                                            0x0E, 0x8E, 0x4E, 0xCE, 0x2E, 0xAE, 0x6E, 0xEE, 0x1E, 0x9E, 0x5E, 0xDE, 0x3E, 0xBE, 0x7E, 0xFE,
                                            0x01, 0x81, 0x41, 0xC1, 0x21, 0xA1, 0x61, 0xE1, 0x11, 0x91, 0x51, 0xD1, 0x31, 0xB1, 0x71, 0xF1,
                                            0x09, 0x89, 0x49, 0xC9, 0x29, 0xA9, 0x69, 0xE9, 0x19, 0x99, 0x59, 0xD9, 0x39, 0xB9, 0x79, 0xF9,
                                            0x05, 0x85, 0x45, 0xC5, 0x25, 0xA5, 0x65, 0xE5, 0x15, 0x95, 0x55, 0xD5, 0x35, 0xB5, 0x75, 0xF5,
                                            0x0D, 0x8D, 0x4D, 0xCD, 0x2D, 0xAD, 0x6D, 0xED, 0x1D, 0x9D, 0x5D, 0xDD, 0x3D, 0xBD, 0x7D, 0xFD,
                                            0x03, 0x83, 0x43, 0xC3, 0x23, 0xA3, 0x63, 0xE3, 0x13, 0x93, 0x53, 0xD3, 0x33, 0xB3, 0x73, 0xF3,
                                            0x0B, 0x8B, 0x4B, 0xCB, 0x2B, 0xAB, 0x6B, 0xEB, 0x1B, 0x9B, 0x5B, 0xDB, 0x3B, 0xBB, 0x7B, 0xFB,
                                            0x07, 0x87, 0x47, 0xC7, 0x27, 0xA7, 0x67, 0xE7, 0x17, 0x97, 0x57, 0xD7, 0x37, 0xB7, 0x77, 0xF7,
                                            0x0F, 0x8F, 0x4F, 0xCF, 0x2F, 0xAF, 0x6F, 0xEF, 0x1F, 0x9F, 0x5F, 0xDF, 0x3F, 0xBF, 0x7F, 0xFF};

class TroykaLedMatrix
{
public:
    TroykaLedMatrix();
    TroykaLedMatrix(const uint8_t addr);
    void begin();
    void begin(TwoWire& wire);
    void enableDisplay();
    void disableDisplay();
    void enableAudioInput();
    void disableAudioInput();
    void enableEqualizer();
    void disableEqualizer();
    void setAudioGain(const uint8_t value);
    void setCurrentLimit(const uint8_t value);
    void setMatrixSize(const uint8_t value);
    void clear();
    void selectFont(const uint8_t fontID);
    void setFont(const uint8_t* font, const uint8_t countChars = 1, const uint8_t countRaws = 8);
    void clearPixel(const uint8_t x, const uint8_t y);
    void drawPixel(const uint8_t x, const uint8_t y);
    void drawSymbol(const uint8_t c);
    void drawBitmap(const uint8_t* data, const bool reverse = true, const uint8_t countRaws = 8);
    void marquee(const uint8_t data[][8], const int len, const int sh, const bool reverse = true);
    void drawBitmapF(const uint8_t* data, const uint8_t countRaws = 8);
    byte map(long input, long in_min, long in_max);
    void marqueeText(char text[], uint8_t len, uint16_t sh);
    void setRotation(const uint8_t value);
    void update();

private:
    void _init();
    void _updateDisplay();
    uint8_t _getRow(const uint8_t y);
    uint8_t _readReg(const uint8_t addr);
    void _writeReg(const uint8_t addr, const uint8_t data);
    uint8_t _makeConfigReg();
    uint8_t _makeEffectReg();
    uint8_t _addr;
    bool _shutDown;
    bool _audioInput;
    uint8_t _matrixSize;
    uint8_t _width;
    uint8_t _height;
    uint8_t _audioInputGain;
    uint8_t _currentLimit;
    bool _audioEqualizer;
    const uint8_t* _font;
    uint8_t _fontSize;
    uint8_t _fontHeight;
    uint8_t _data[MATRIX_MAX_ROWS];
    TwoWire* _wire;
    uint8_t _rotation;
};

TroykaLedMatrix::TroykaLedMatrix() {
    _addr = I2C_ADDR_BASE | (I2C_ADDR_ALT0 & I2C_ADDR_MASK);
}

TroykaLedMatrix::TroykaLedMatrix(const uint8_t addr) {
    _addr = I2C_ADDR_BASE | (addr & I2C_ADDR_MASK);
}

void TroykaLedMatrix::_init() {
    _shutDown = false;
    _audioInput = false;
    _audioEqualizer = false;
    _audioInputGain = AUDIO_GAIN_0DB;
    setCurrentLimit(ROW_CURRENT_05MA);
    setMatrixSize(MATRIX_SIZE_8X8);
    _writeReg(REG_ADDR_CONFIGURATION, _makeConfigReg());
    _writeReg(REG_ADDR_LIGHTING_EFFECT, _makeEffectReg());
    disableEqualizer();
    setRotation(ROTATION_0);
}

void TroykaLedMatrix::begin(TwoWire& wire) {
    _wire = &wire;
    _init();
}

void TroykaLedMatrix::begin() {
    Wire.begin();
    begin(Wire);
}

void TroykaLedMatrix::enableDisplay() {
    _shutDown = false;
    uint8_t data = _makeConfigReg();
    _writeReg(REG_ADDR_CONFIGURATION, data);
}

void TroykaLedMatrix::disableDisplay() {
    _shutDown = true;
    uint8_t data = _makeConfigReg();
    _writeReg(REG_ADDR_CONFIGURATION, data);
}

void TroykaLedMatrix::enableAudioInput() {
    _audioInput = true;
    uint8_t data = _makeConfigReg();
    _writeReg(REG_ADDR_CONFIGURATION, data);
}

void TroykaLedMatrix::disableAudioInput() {
    _audioInput = false;
    uint8_t data = _makeConfigReg();
    _writeReg(REG_ADDR_CONFIGURATION, data);
}

void TroykaLedMatrix::enableEqualizer() {
    _audioEqualizer = true;
    _writeReg(REG_ADDR_AUDIO_EQUALIZER, _BV(BIT_AUDIO_EQ_EN));
}

void TroykaLedMatrix::disableEqualizer() {
    _audioEqualizer = false;
    _writeReg(REG_ADDR_AUDIO_EQUALIZER, 0);
}

void TroykaLedMatrix::setAudioGain(const uint8_t value) {
    _audioInputGain = value & AUDIO_GAIN_MASK;
    uint8_t data = _makeEffectReg();
    _writeReg(REG_ADDR_LIGHTING_EFFECT, data);
}

void TroykaLedMatrix::setCurrentLimit(const uint8_t value) {
    _currentLimit = value & ROW_CURRENT_MASK;
    uint8_t data = _makeEffectReg();
    _writeReg(REG_ADDR_LIGHTING_EFFECT, data);
}

void TroykaLedMatrix::setMatrixSize(const uint8_t value) {
    _matrixSize = (value & MATRIX_SIZE_MASK);
    uint8_t data = _makeConfigReg();
    _writeReg(REG_ADDR_CONFIGURATION, data);
    switch (_matrixSize) {
        case MATRIX_SIZE_8X8: { 
            _width = 8;
            _height = 8;
            break; 
        }
        case MATRIX_SIZE_7X9: {
            _width = 7;
            _height = 9;
            break;
        }
        case MATRIX_SIZE_6X10: {
            _width = 6;
            _height = 10;
            break; 
        }
        case MATRIX_SIZE_5X11: { 
            _width = 5;
            _height = 11;
            break;
        }
    }
}

void TroykaLedMatrix::clear() {
    for (uint8_t i = 0; i < MATRIX_MAX_ROWS; i++) {
        _data[i] = 0;
    }
}

void TroykaLedMatrix::clearPixel(const uint8_t x, const uint8_t y) {
    uint8_t i = x % 8;
    uint8_t j = y % MATRIX_MAX_ROWS;
    _data[j] = _data[j] & ~_BV(i);
}

void TroykaLedMatrix::drawPixel(const uint8_t x, const uint8_t y) {
    uint8_t i = x % 8;
    uint8_t j = y % MATRIX_MAX_ROWS;
    _data[j] = _data[j] | _BV(i);
}

void TroykaLedMatrix::selectFont(const uint8_t fontID) {
    switch (fontID) {
        default:
        case FONT_8X8_BASIC: {
            setFont((const uint8_t *)font8x8_basic, 128, 8);
            break;
        }
        case FONT_8X8_CONTROL: {
            setFont((const uint8_t *)font8x8_control, 32, 8);
            break;
        }
        case FONT_8X8_EXT_LATIN: {
            setFont((const uint8_t *)font8x8_ext_latin, 96, 8);
            break;
        }
        case FONT_8X8_GREEK: {
            setFont((const uint8_t *)font8x8_greek, 58, 8);
            break;
        }
        case FONT_8X8_MISC: {
            setFont((const uint8_t *)font8x8_misc, 10, 8);
            break;
        }
        case FONT_8X8_BOX: {
            setFont((const uint8_t *)font8x8_box, 128, 8);
            break;
        }
        case FONT_8X8_BLOCK: {
            setFont((const uint8_t *)font8x8_block, 32, 8);
            break;
        }
        case FONT_8X8_HIRAGANA: {
            setFont((const uint8_t *)font8x8_hiragana, 96, 8);
            break;
        }
        case FONT_8X8_SGA: {
            setFont((const uint8_t *)font8x8_sga, 26, 8);
            break;
        }
    }
}

void TroykaLedMatrix::setFont(const uint8_t* font, const uint8_t countChars, const uint8_t countRaws) {
    _font = font;
    _fontSize = countChars;
    _fontHeight = countRaws;
}

void TroykaLedMatrix::drawSymbol(const uint8_t c) {
    if (_font) {
        if (c < _fontSize) {
            drawBitmapF(&_font[c * _fontHeight], _fontHeight);
        }
    }
}

void TroykaLedMatrix::drawBitmap(const uint8_t* data, bool const reverse, const uint8_t countRaws) {
    uint8_t n = min((uint8_t)countRaws, (uint8_t)MATRIX_MAX_ROWS);
    for (uint8_t i = 0; i < n; i++) {
        if (reverse) {
            _data[i] = pgm_read_byte(&RER_BIT_MAP[data[i]]);
        } else {
            _data[i] = data[i];
        }
    }
}

void TroykaLedMatrix::marquee(const uint8_t data[][8], const int len, const int sh, bool const reverse) {
    byte frame = sh / 8;
    byte col = sh % 8;
    for (uint8_t i = 0; i < 8; i++) {
        if (reverse) {
           byte line = data[frame % len][i] << col;
           line |= data[(frame+1) % len][i] >> (8 - col);
           _data[i] = pgm_read_byte(&RER_BIT_MAP[line]);
       } else {
           _data[i] = data[frame % len][i] << col;
           _data[i] |= data[(frame+1) % len][i] >> (8 - col);
       }
   }
}

void TroykaLedMatrix::drawBitmapF(const uint8_t* data, const uint8_t countRaws) {

    uint8_t n = min((uint8_t)countRaws, (uint8_t)MATRIX_MAX_ROWS);
    for (uint8_t i = 0; i < n; i++) {
        _data[i] = pgm_read_byte(&data[i]);
    }
}

byte TroykaLedMatrix::map(long input, long in_min, long in_max) {
	byte output = (input - in_min) * 8 / (in_max - in_min);
	return 0b11111111 >> output;
}

void TroykaLedMatrix::_updateDisplay() {
    uint8_t h = _height;
    for (uint8_t i = 0; i < h; i++) {
        uint8_t data = _getRow(i);
        _writeReg(REG_ADDR_COLUMN_DATA + i, data);
    }
    _writeReg(REG_ADDR_UPDATE_COLUMN, 0xff);
}

uint8_t TroykaLedMatrix::_getRow(const uint8_t y) {
    uint8_t result = 0;
    switch (_rotation) {
        default:
        case ROTATION_0: {
            result = _data[y % _height];
            break;
        }
        case ROTATION_90: {
            uint8_t mask = 1 << y;
            for (uint8_t i=0; i < 8; ++i) {
                result |=(_data[i] & mask)?(0x80>>i):0;
            }
            break;
        }
        case ROTATION_180: {
            uint8_t row = _data[_height - 1 - (y % _height)];
            for (uint8_t i=0; i < _height; ++i) {
                result >>= 1;
                result |= row & 0x80;
                row <<= 1;
            }
            break;
        }
        case ROTATION_270: {
            uint8_t mask = 0x80>>y;
            for (uint8_t i=0; i < 8; ++i) {
                result |=(_data[i] & mask)?(1<<i):0;
            }
            break;
        }
    }
    return result;
}

uint8_t TroykaLedMatrix::_readReg(const uint8_t addr) {
    _wire->beginTransmission(_addr);
    _wire->write(addr);
    _wire->endTransmission();
    _wire->requestFrom(_addr, (uint8_t)1);
    uint8_t data = _wire->read();
    return data; 
}

void TroykaLedMatrix::_writeReg(const uint8_t addr, const uint8_t data) {
    _wire->beginTransmission(_addr);
    _wire->write(addr);
    _wire->write(data);
    _wire->endTransmission();
}

uint8_t TroykaLedMatrix::_makeConfigReg() {
    uint8_t data = 0;
    if (_shutDown) {
        data |= _BV(BIT_CONFIG_SSD);
    }
    if (_audioInput) {
        data |= _BV(BIT_CONFIG_AUDIO_EN);
    }
    data |= _matrixSize << BIT_CONFIG_ADM;
    return data;
}

uint8_t TroykaLedMatrix::_makeEffectReg() {
    uint8_t data = (_audioInputGain << BIT_EFFECT_AUDIO_GAIN) |
    (_currentLimit << BIT_EFFECT_ROW_CURRENT);
    return data;
}

void TroykaLedMatrix::marqueeText(char text[], uint8_t len, uint16_t sh) {
    uint8_t frame = sh / 8;
    uint8_t col = sh % 8;
    uint8_t firstSymCol = 8 - col;
    if (_font) {
        if (frame < len) {
            if (text[frame] < _fontSize) {
                for (uint8_t i = 0; i < 8; i++) {
                    uint16_t line = text[frame] * 8 + i;
                    _data[i] = pgm_read_byte(&_font[line]) >> col;
                }                 
            }
        }
        if (frame + 1 < len) {
            if (text[frame+1] < _fontSize) {
                for (uint8_t i = 0; i < 8; i++) {
                    uint16_t line = text[frame + 1] * 8 + i;
                    _data[i] |= pgm_read_byte(&_font[line]) << firstSymCol;
                }                 
            }
        }
    }
}

void TroykaLedMatrix::setRotation(const uint8_t value) {
    _rotation = value;
}

void TroykaLedMatrix::update()
{
    _updateDisplay();
}

#endif //TROYKA_LED_MATRIX


#define SWAP_LEFT 0b00000010
#define SWAP_RIGHT 0b00000001
#define SWAP_BOTH 0b00000011

// Motor start rotation then PWM value more then MMIN_DEFAULT
constexpr byte MMIN_DEFAULT = 25;

// Constants for different motors types:
// maximal voltage (0...255) in case of motor active resistance
constexpr byte MMAX_3_OHM = 80;
constexpr byte MMAX_16_OHM = 255;

class Dragster {
public:
	Dragster()
	{
		setMotorLimits(MMAX_3_OHM, MMIN_DEFAULT, MMIN_DEFAULT);
	}

	Dragster(byte motorMax)
	{
		setMotorLimits(motorMax, MMIN_DEFAULT, MMIN_DEFAULT);
	}

	Dragster(byte motorMax, byte motorMinForward, byte motorMinBackward)
	{
		setMotorLimits(motorMax, motorMinForward, motorMinBackward);
	}

	void begin()
	{
		pinMode(4, OUTPUT);
		pinMode(7, OUTPUT);
		pinMode(5, OUTPUT);
		pinMode(6, OUTPUT);

		pinMode(10, INPUT);
		pinMode(13, OUTPUT);
	}

	void begin(int direction)
	{
		if (direction & SWAP_LEFT) {
			_swappedLeft = 0;
		}
		if (direction & SWAP_RIGHT) {
			_swappedRight = 1;
		}
		begin();
	}

	void drive(int left, int right)
	{
		driveMotor(left, _swappedLeft, 7, 6);
    	driveMotor(right, _swappedRight, 4, 5);
	}

	void driveF(float left, float right)
	{
		drive((int)(left * 255.0), (int)(right * 255.0));
	}

	void encodersBegin(void (*left)(), void (*right)())
	{
		attachInterrupt(2, left, CHANGE);
    	attachInterrupt(3, right, CHANGE);
	}

	static bool ReadButton()
	{
		return digitalRead(10);
	}

	static void Led(bool state)
	{
		digitalWrite(13, state);
	}

	static float GetBatteryCharge()
	{
		int adcValue = analogRead(A1);
		float V = adcValue * 5.0 / 1023.0;
		float Vbat = V * (46000) / 36000;
		return (Vbat - 3.2) / 0.8;
	}

private:
	void driveMotor(int speed, int swapped, byte dir, byte drv)
	{
		if (swapped)
			speed = -speed;
		if (speed == 0) {
			analogWrite(drv, 0);
		} else if (speed > 0) {
			digitalWrite(dir, HIGH);
			analogWrite(drv, map(speed, 0, 255, _motorMinForward, _motorMax));
		} else {
			digitalWrite(dir, LOW);
			analogWrite(drv, map(-speed, 0, 255, _motorMinBackward, _motorMax));
		}
	}

	void setMotorLimits(byte motorMax, byte motorMinForward, byte motorMinBackward)
	{
		_motorMax = motorMax;
		_motorMinForward = motorMinForward;
		_motorMinBackward = motorMinBackward;
	}

	byte _swappedLeft = 1;
	byte _swappedRight = 0;

	byte _motorMax;
	byte _motorMinForward;
	byte _motorMinBackward;
}; // class Dragster

#endif //__DRAGSTER_H__
